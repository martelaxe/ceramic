import{CommitID as q,StreamRef as J}from"@ceramicnetwork/streamid";import{TileDocument as O}from"@ceramicnetwork/stream-tile";import{CIP88_REF_PREFIX as F,CIP11_DEFINITION_SCHEMA_URL as it,CIP88_APPEND_COLLECTION_PREFIX as B}from"@glazed/constants";import{model as st}from"@glazed/did-datastore-model";import rt from"cids";import{fromString as nt,toString as at}from"uint8arrays";import{camelCase as ot,pascalCase as ct}from"change-case";import G from"ajv";import lt from"ajv-formats";function dt(t){return typeof t=="string"?t:t.toString()}function p(t,e){return Object.entries(t).reduce((i,[n,r])=>(i[n]=e(r),i),{})}async function H(t,e){const i=await Promise.all(Object.values(t).map(n=>e(n)));return Object.keys(t).reduce((n,r,a)=>(n[r]=i[a],n),{})}function V({payload:t,signatures:e,link:i}){return{payload:t,signatures:e,link:i?new rt(i):void 0}}function X({payload:t,signatures:e,link:i}){return{payload:t,signatures:e,link:i?.toString()}}function P({jws:t,linkedBlock:e}){return{jws:V(t),linkedBlock:nt(e,"base64pad")}}function j({jws:t,linkedBlock:e}){return{jws:X(t),linkedBlock:at(e,"base64pad")}}function mt(t){return p(t,e=>e.map(P))}function ht(t){return p(t,e=>e.map(j))}function _(t){return{...t,commits:t.commits.map(P)}}function I(t){return{schemas:p(t.schemas,e=>({...e,commits:e.commits.map(P)})),definitions:p(t.definitions,_),tiles:p(t.tiles,_)}}function T(t){return{...t,commits:t.commits.map(j)}}function Q(t){return{schemas:p(t.schemas,e=>({...e,commits:e.commits.map(j)})),definitions:p(t.definitions,T),tiles:p(t.tiles,T)}}const N={anchor:!1};async function C(t,e,i={}){const n=await O.create(t,e,i,N);return await t.pin.add(n.id),n}async function S(t,[e,...i]){const n=await O.createFromGenesis(t,e,N);await t.pin.add(n.id);for(const r of i)await t.applyCommit(n.id,r,N);return n}async function ft(t,e){return await H(e,async i=>await S(t,i))}function b(t){if(t.$comment?.startsWith(F)){const e=t.$comment.substr(F.length);if(e.length){const i=e.split("|");return i.sort(),i}}return null}function M(t,e=""){if(t.type==="string"){const i=b(t);return i!=null&&i.length>0?{[e]:i}:{}}return t.type==="array"?M(t.items,e):t.type==="object"&&t.properties!=null?Object.entries(t.properties).reduce((i,[n,r])=>{const a=e===""?n:`${e}.${n}`;return Object.assign(i,M(r,a))},{}):{}}var z=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},s=(t,e,i)=>(z(t,e,"read from private field"),i?i.call(t):e.get(t)),E=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},ut=(t,e,i,n)=>(z(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),h,c,m,u,$;function pt(t){const e=typeof t=="string"?J.from(t):t;return[e.baseID.toString(),q.isInstance(e)?e.toString():null]}function K(t){return(typeof t=="string"?J.from(t):t).baseID.toString()}function A(t){return t.startsWith("did:key")}function Y(t){return A(t.metadata.controllers[0])}const wt=I(st);async function k(t){await Promise.all(Object.values(wt.schemas).map(async e=>await S(t,e.commits)))}async function x(t,e){const[i]=await Promise.all([Promise.all(Object.values(e.schemas).map(async a=>{const l=await S(t,a.commits);return[a.alias,l.commitId.toUrl()]})),k(t)]),[n,r]=await Promise.all([await Promise.all(Object.values(e.definitions).map(async a=>{const l=await S(t,a.commits);return[a.alias,l.id.toString()]})),await Promise.all(Object.values(e.tiles).map(async a=>{const l=await S(t,a.commits);return[a.alias,l.id.toString()]}))]);return{definitions:Object.fromEntries(n),schemas:Object.fromEntries(i),tiles:Object.fromEntries(r)}}async function St(t,e){return await x(t,I(e))}const Z=class{constructor(t,e){E(this,h,{definitions:{},schemas:{},tiles:{}}),E(this,c,void 0),E(this,m,{definitions:{},schemas:{},tiles:{}}),E(this,u,{}),E(this,$,{}),ut(this,c,t),e!=null&&this.addModel(e)}static fromJSON(t,e){return new Z(t,I(e))}get model(){return s(this,m)}get schemas(){return Object.keys(s(this,h).schemas).sort()}get definitions(){return Object.keys(s(this,h).definitions).sort()}get tiles(){return Object.keys(s(this,h).tiles).sort()}addModel(t){Object.assign(s(this,m).definitions,t.definitions),Object.assign(s(this,m).schemas,t.schemas),Object.assign(s(this,m).tiles,t.tiles);for(const[e,i]of Object.entries(t.schemas)){s(this,h).schemas[i.alias]=e;for(const n of Object.values(i.dependencies))for(const r of n)s(this,u)[r]==null&&(s(this,u)[r]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,u)[r].schemas.add(e)}for(const[e,i]of Object.entries(t.definitions))s(this,h).definitions[i.alias]=e,s(this,u)[i.schema]==null&&(s(this,u)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,u)[i.schema].definitions.add(e);for(const[e,i]of Object.entries(t.tiles))s(this,h).tiles[i.alias]=e,s(this,u)[i.schema]==null&&(s(this,u)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,u)[i.schema].tiles.add(e)}addJSONModel(t){this.addModel(I(t))}async loadStream(t){const e=typeof t=="string"?t:t.baseID.toString();return s(this,$)[e]==null&&(s(this,$)[e]=this._loadAndValidateStream(e)),await s(this,$)[e]}async _loadAndValidateStream(t){const e=await O.load(s(this,c),t);if(e.anchorCommitIds.length!==0)throw new Error(`Invalid stream ${t}: contains anchor commit`);if(e.allCommitIds.length===1&&Y(e))return e;if((await Promise.all(e.allCommitIds.map(async r=>await O.load(s(this,c),r)))).find(r=>!Y(r))!=null)throw new Error(`Invalid stream ${t}: contains a commit authored by an unsupported DID`);return e}async loadCommits(t){return(await s(this,c).loadStreamCommits(t)).map(i=>i.value)}async loadSchema(t,e){const[i,n]=pt(t);if(n===null)throw new Error(`Expected CommitID to load schema: ${i}`);const r=s(this,m).schemas[i];if(r!=null){if(r.version!==n)throw new Error(`Another version for this schema is already set: ${r.version}`);if(e!=null&&r.alias!==e)throw new Error(`Another alias for this schema is already set: ${r.alias}`);return i}const[a,l]=await Promise.all([this.loadStream(n),this.loadCommits(i)]),o=a.content??{},d=e??o.title;if(d==null)throw new Error("Schema must have a title property or an alias must be provided");const f=await this.loadSchemaDependencies(o);return s(this,m).schemas[i]={alias:d,commits:l,dependencies:f,version:n},s(this,h).schemas[d]=i,i}async loadSchemaDependencies(t){const e=M(t),i=new Set;for(const a of Object.values(e))for(const l of a)i.add(l);const n=await Promise.all(Array.from(i).map(async a=>[a,await this.loadSchema(a)])),r=Object.fromEntries(n);return Object.entries(e).reduce((a,[l,o])=>(a[l]=o.map(d=>r[d]),a),{})}async create(t,e,i,n){switch(t){case"schema":return await this.createSchema(e,i);case"definition":return await this.createDefinition(e,i);case"tile":return await this.createTile(e,i,n);default:throw new Error(`Unsupported type: ${t}`)}}async usePublished(t,e,i){switch(t){case"schema":return await this.usePublishedSchema(e,i);case"definition":return await this.usePublishedDefinition(e,i);case"tile":return await this.usePublishedTile(e,i);default:throw new Error(`Unsupported type: ${t}`)}}getSchemaID(t){return s(this,h).schemas[t]??null}hasSchemaAlias(t){return this.getSchemaID(t)!=null}getSchema(t){return s(this,m).schemas[t]??null}getSchemaURL(t){const e=s(this,m).schemas[t];return e?q.fromString(e.version).toUrl():null}getSchemaByAlias(t){const e=this.getSchemaID(t);return e?this.getSchema(e):null}async createSchema(t,e){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!A(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasSchemaAlias(t))throw new Error(`Schema ${t} already exists`);const[i,n]=await Promise.all([C(s(this,c),e),this.loadSchemaDependencies(e)]),r=i.id.toString();return s(this,m).schemas[r]={alias:t,commits:await this.loadCommits(r),dependencies:n,version:i.commitId.toString()},s(this,h).schemas[t]=r,r}async usePublishedSchema(t,e){if(t==null)throw new Error("Schema alias must be provided");return await this.loadSchema(e,t)}getDefinitionID(t){return s(this,h).definitions[t]??null}hasDefinitionAlias(t){return this.getDefinitionID(t)!=null}getDefinition(t){return s(this,m).definitions[t]??null}async createDefinition(t,e){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!A(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasDefinitionAlias(t))throw new Error(`Definition ${t} already exists`);await k(s(this,c));const[i,n]=await Promise.all([C(s(this,c),e,{schema:it}),this.loadSchema(e.schema)]),r=i.id.toString();return s(this,m).definitions[r]={alias:t,commits:await this.loadCommits(r),schema:n,version:i.commitId.toString()},s(this,h).definitions[t]=r,r}async usePublishedDefinition(t,e){if(this.hasDefinitionAlias(t))throw new Error(`Definition ${t} already exists`);const i=K(e),[n,r]=await Promise.all([this.loadStream(e),this.loadCommits(i)]);return s(this,m).definitions[i]={alias:t,commits:r,schema:await this.loadSchema(n.content.schema),version:n.commitId.toString()},s(this,h).definitions[t]=i,i}getTileID(t){return s(this,h).tiles[t]??null}hasTileAlias(t){return this.getTileID(t)!=null}getTile(t){return s(this,m).tiles[t]??null}async createTile(t,e,i={}){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!A(s(this,c).did.id))throw new Error("Unsupported DID to create stream for model");if(this.hasTileAlias(t))throw new Error(`Tile ${t} already exists`);if(i.schema==null)throw new Error(`Missing schema to create tile ${t}`);const[n,r]=await Promise.all([C(s(this,c),e,i),this.loadSchema(i.schema)]),a=n.id.toString();return s(this,m).tiles[a]={alias:t,commits:await this.loadCommits(a),schema:r,version:n.commitId.toString()},s(this,h).tiles[t]=a,a}async usePublishedTile(t,e){if(this.hasTileAlias(t))throw new Error(`Tile ${t} already exists`);const i=K(e),[n,r]=await Promise.all([this.loadStream(e),this.loadCommits(i)]);if(n.metadata.schema==null)throw new Error("Loaded tile has no schema defined");return s(this,m).tiles[i]={alias:t,commits:r,schema:await this.loadSchema(n.metadata.schema),version:n.commitId.toString()},s(this,h).tiles[t]=i,i}async toPublished(){return await x(s(this,c),s(this,m))}toJSON(){return Q(s(this,m))}};let yt=Z;h=new WeakMap,c=new WeakMap,m=new WeakMap,u=new WeakMap,$=new WeakMap;function W(t,e=""){const i=ct(t);return i.startsWith(e)?i:e+i}function L(t,e,i,n){const r=e.title??"";if(e.type==="array")throw new Error("Unsupported item field of type array");if(e.type==="string"){const a=b(e);if(a==null)return{...e,type:"string"};const l=W(r,i),o={schemas:a,owner:n};return t.references[l]=o,{type:"reference",...o}}return e.type==="object"?{type:"object",name:v(t,e,{name:r,parent:i,owner:n})}:e}function v(t,e,i={}){const n=i.name??e.title;if(n==null)throw new Error("Schema must have a title");const r=W(n,i.parent);if(e.type==="string"){const a=b(e);a!=null&&(t.references[r]={schemas:a,owner:i.owner})}else if(e.type==="array"&&e.items!=null)t.lists[r]=L(t,e.items,r,i.owner);else if(e.type==="object"&&e.properties!=null){const a=e.required??[],l=Object.entries(e.properties).reduce((o,[d,f])=>{const y=f.title??d,w=ot(d),g={name:y,parent:r,owner:i.owner??r},D=a.includes(d);if(f.type==="string"){const R=b(f);if(R==null)o[w]={...f,required:D,type:"string"};else{const et=W(y,r),U={schemas:R,owner:i.owner??r};t.references[et]=U,o[w]={required:D,type:"reference",...U}}}else if(f.type==="array"){if(f.items==null)throw new Error(`Missing items in field ${d}`);o[w]={required:D,type:"list",name:v(t,f,g)}}else f.type==="object"?o[w]={required:D,type:"object",name:v(t,f,g)}:o[w]={...f,required:D};return o},{});t.objects[r]={fields:l,parents:i.parent?[i.parent]:null}}return r}async function gt(t){const e={collections:{},index:{},lists:{},objects:{},referenced:{},references:{},roots:{}},i=t.schemas.map(async a=>{const l=t.getSchemaID(a),o=await t.loadStream(l),d=o.content;if(d==null)throw new Error(`Could not load schema ${a}`);const f=o.commitId.toUrl();if(d.$comment?.startsWith(B)){const y=d.$comment.substr(B.length);await t.loadSchema(y);const g=(await t.loadStream(y)).content?.properties?.contents?.items?.oneOf?.[0];if(g==null)throw new Error(`Could not extract item schema ${a}`);e.collections[a]={schema:f,item:L(e,g,a,a)},e.referenced[f]={type:"collection",name:a}}else e.referenced[f]={type:"object",name:v(e,d)}}),n=t.definitions.map(async a=>{const l=t.getDefinitionID(a),o=await t.loadStream(l),d=o.content;if(d==null)throw new Error(`Could not load definition ${a}`);e.index[a]={id:o.id.toString(),schema:d.schema}}),r=t.tiles.map(async a=>{const l=t.getTileID(a),o=await t.loadStream(l),{schema:d}=o.metadata;if(d==null)throw new Error(`Missing schema for tile ${a}`);e.roots[a]={id:o.id.toString(),schema:d}});return await Promise.all([...i,...n,...r]),e}const tt=new G({strict:!1}).compile({$schema:"http://json-schema.org/draft-07/schema#",$id:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/json-schema-secure.json#",title:"Meta-schema for the security assessment of JSON Schemas",description:"If a JSON AnySchema fails validation against this meta-schema, it may be unsafe to validate untrusted data",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}}},dependencies:{patternProperties:{description:"prevent slow validation of large property names",required:["propertyNames"],properties:{propertyNames:{required:["maxLength"]}}},uniqueItems:{description:"prevent slow validation of large non-scalar arrays",if:{properties:{uniqueItems:{const:!0},items:{properties:{type:{anyOf:[{enum:["object","array"]},{type:"array",contains:{enum:["object","array"]}}]}}}}},then:{required:["maxItems"]}},pattern:{description:"prevent slow pattern matching of large strings",required:["maxLength"]},format:{description:"prevent slow format validation of large strings",required:["maxLength"]}},properties:{additionalItems:{$ref:"#"},additionalProperties:{$ref:"#"},dependencies:{additionalProperties:{anyOf:[{type:"array"},{$ref:"#"}]}},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}]},definitions:{additionalProperties:{$ref:"#"}},patternProperties:{additionalProperties:{$ref:"#"}},properties:{additionalProperties:{$ref:"#"}},if:{$ref:"#"},then:{$ref:"#"},else:{$ref:"#"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"},contains:{$ref:"#"},propertyNames:{$ref:"#"}}});function Dt(t){const e=new G;return lt(e),e.compile(t),tt(t)}export{yt as ModelManager,v as addModelSchema,p as applyMap,gt as createGraphQLModel,C as createModelDoc,V as decodeDagJWS,P as decodeDagJWSResult,_ as decodeEntryCommits,I as decodeModel,mt as decodeSignedMap,X as encodeDagJWS,j as encodeDagJWSResult,T as encodeEntryCommits,Q as encodeModel,ht as encodeSignedMap,M as extractSchemaReferences,L as getItemField,b as getReference,Dt as isSecureSchema,H as promiseMap,S as publishCommits,k as publishDataStoreSchemas,St as publishEncodedModel,x as publishModel,ft as publishSignedMap,dt as streamIDToString,tt as validateSchemaSecure};
//# sourceMappingURL=lib.mjs.map
