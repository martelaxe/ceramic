"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var C=require("@ceramicnetwork/streamid"),$=require("@ceramicnetwork/stream-tile"),I=require("@glazed/constants"),se=require("@glazed/did-datastore-model"),re=require("cids"),B=require("uint8arrays"),G=require("change-case"),ne=require("ajv"),ae=require("ajv-formats");function q(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var oe=q(re),X=q(ne),ce=q(ae);function de(e){return typeof e=="string"?e:e.toString()}function p(e,t){return Object.entries(e).reduce((i,[n,r])=>(i[n]=t(r),i),{})}async function H(e,t){const i=await Promise.all(Object.values(e).map(n=>t(n)));return Object.keys(e).reduce((n,r,a)=>(n[r]=i[a],n),{})}function V({payload:e,signatures:t,link:i}){return{payload:e,signatures:t,link:i?new oe.default(i):void 0}}function z({payload:e,signatures:t,link:i}){return{payload:e,signatures:t,link:i?.toString()}}function j({jws:e,linkedBlock:t}){return{jws:V(e),linkedBlock:B.fromString(t,"base64pad")}}function O({jws:e,linkedBlock:t}){return{jws:z(e),linkedBlock:B.toString(t,"base64pad")}}function le(e){return p(e,t=>t.map(j))}function me(e){return p(e,t=>t.map(O))}function R(e){return{...e,commits:e.commits.map(j)}}function b(e){return{schemas:p(e.schemas,t=>({...t,commits:t.commits.map(j)})),definitions:p(e.definitions,R),tiles:p(e.tiles,R)}}function N(e){return{...e,commits:e.commits.map(O)}}function Q(e){return{schemas:p(e.schemas,t=>({...t,commits:t.commits.map(O)})),definitions:p(e.definitions,N),tiles:p(e.tiles,N)}}const W={anchor:!1};async function _(e,t,i={}){const n=await $.TileDocument.create(e,t,i,W);return await e.pin.add(n.id),n}async function S(e,[t,...i]){const n=await $.TileDocument.createFromGenesis(e,t,W);await e.pin.add(n.id);for(const r of i)await e.applyCommit(n.id,r,W);return n}async function he(e,t){return await H(t,async i=>await S(e,i))}function v(e){if(e.$comment?.startsWith(I.CIP88_REF_PREFIX)){const t=e.$comment.substr(I.CIP88_REF_PREFIX.length);if(t.length){const i=t.split("|");return i.sort(),i}}return null}function T(e,t=""){if(e.type==="string"){const i=v(e);return i!=null&&i.length>0?{[t]:i}:{}}return e.type==="array"?T(e.items,t):e.type==="object"&&e.properties!=null?Object.entries(e.properties).reduce((i,[n,r])=>{const a=t===""?n:`${t}.${n}`;return Object.assign(i,T(r,a))},{}):{}}var K=(e,t,i)=>{if(!t.has(e))throw TypeError("Cannot "+i)},s=(e,t,i)=>(K(e,t,"read from private field"),i?i.call(e):t.get(e)),E=(e,t,i)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,i)},ue=(e,t,i,n)=>(K(e,t,"write to private field"),n?n.call(e,i):t.set(e,i),i),h,c,m,f,M;function fe(e){const t=typeof e=="string"?C.StreamRef.from(e):e;return[t.baseID.toString(),C.CommitID.isInstance(t)?t.toString():null]}function Y(e){return(typeof e=="string"?C.StreamRef.from(e):e).baseID.toString()}function A(e){return e.startsWith("did:key")}function Z(e){return A(e.metadata.controllers[0])}const pe=b(se.model);async function k(e){await Promise.all(Object.values(pe.schemas).map(async t=>await S(e,t.commits)))}async function x(e,t){const[i]=await Promise.all([Promise.all(Object.values(t.schemas).map(async a=>{const d=await S(e,a.commits);return[a.alias,d.commitId.toUrl()]})),k(e)]),[n,r]=await Promise.all([await Promise.all(Object.values(t.definitions).map(async a=>{const d=await S(e,a.commits);return[a.alias,d.id.toString()]})),await Promise.all(Object.values(t.tiles).map(async a=>{const d=await S(e,a.commits);return[a.alias,d.id.toString()]}))]);return{definitions:Object.fromEntries(n),schemas:Object.fromEntries(i),tiles:Object.fromEntries(r)}}async function we(e,t){return await x(e,b(t))}const ee=class{constructor(e,t){E(this,h,{definitions:{},schemas:{},tiles:{}}),E(this,c,void 0),E(this,m,{definitions:{},schemas:{},tiles:{}}),E(this,f,{}),E(this,M,{}),ue(this,c,e),t!=null&&this.addModel(t)}static fromJSON(e,t){return new ee(e,b(t))}get model(){return s(this,m)}get schemas(){return Object.keys(s(this,h).schemas).sort()}get definitions(){return Object.keys(s(this,h).definitions).sort()}get tiles(){return Object.keys(s(this,h).tiles).sort()}addModel(e){Object.assign(s(this,m).definitions,e.definitions),Object.assign(s(this,m).schemas,e.schemas),Object.assign(s(this,m).tiles,e.tiles);for(const[t,i]of Object.entries(e.schemas)){s(this,h).schemas[i.alias]=t;for(const n of Object.values(i.dependencies))for(const r of n)s(this,f)[r]==null&&(s(this,f)[r]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[r].schemas.add(t)}for(const[t,i]of Object.entries(e.definitions))s(this,h).definitions[i.alias]=t,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].definitions.add(t);for(const[t,i]of Object.entries(e.tiles))s(this,h).tiles[i.alias]=t,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].tiles.add(t)}addJSONModel(e){this.addModel(b(e))}async loadStream(e){const t=typeof e=="string"?e:e.baseID.toString();return s(this,M)[t]==null&&(s(this,M)[t]=this._loadAndValidateStream(t)),await s(this,M)[t]}async _loadAndValidateStream(e){const t=await $.TileDocument.load(s(this,c),e);if(t.anchorCommitIds.length!==0)throw new Error(`Invalid stream ${e}: contains anchor commit`);if(t.allCommitIds.length===1&&Z(t))return t;if((await Promise.all(t.allCommitIds.map(async r=>await $.TileDocument.load(s(this,c),r)))).find(r=>!Z(r))!=null)throw new Error(`Invalid stream ${e}: contains a commit authored by an unsupported DID`);return t}async loadCommits(e){return(await s(this,c).loadStreamCommits(e)).map(i=>i.value)}async loadSchema(e,t){const[i,n]=fe(e);if(n===null)throw new Error(`Expected CommitID to load schema: ${i}`);const r=s(this,m).schemas[i];if(r!=null){if(r.version!==n)throw new Error(`Another version for this schema is already set: ${r.version}`);if(t!=null&&r.alias!==t)throw new Error(`Another alias for this schema is already set: ${r.alias}`);return i}const[a,d]=await Promise.all([this.loadStream(n),this.loadCommits(i)]),o=a.content??{},l=t??o.title;if(l==null)throw new Error("Schema must have a title property or an alias must be provided");const u=await this.loadSchemaDependencies(o);return s(this,m).schemas[i]={alias:l,commits:d,dependencies:u,version:n},s(this,h).schemas[l]=i,i}async loadSchemaDependencies(e){const t=T(e),i=new Set;for(const a of Object.values(t))for(const d of a)i.add(d);const n=await Promise.all(Array.from(i).map(async a=>[a,await this.loadSchema(a)])),r=Object.fromEntries(n);return Object.entries(t).reduce((a,[d,o])=>(a[d]=o.map(l=>r[l]),a),{})}async create(e,t,i,n){switch(e){case"schema":return await this.createSchema(t,i);case"definition":return await this.createDefinition(t,i);case"tile":return await this.createTile(t,i,n);default:throw new Error(`Unsupported type: ${e}`)}}async usePublished(e,t,i){switch(e){case"schema":return await this.usePublishedSchema(t,i);case"definition":return await this.usePublishedDefinition(t,i);case"tile":return await this.usePublishedTile(t,i);default:throw new Error(`Unsupported type: ${e}`)}}getSchemaID(e){return s(this,h).schemas[e]??null}hasSchemaAlias(e){return this.getSchemaID(e)!=null}getSchema(e){return s(this,m).schemas[e]??null}getSchemaURL(e){const t=s(this,m).schemas[e];return t?C.CommitID.fromString(t.version).toUrl():null}getSchemaByAlias(e){const t=this.getSchemaID(e);return t?this.getSchema(t):null}async createSchema(e,t){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!A(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasSchemaAlias(e))throw new Error(`Schema ${e} already exists`);const[i,n]=await Promise.all([_(s(this,c),t),this.loadSchemaDependencies(t)]),r=i.id.toString();return s(this,m).schemas[r]={alias:e,commits:await this.loadCommits(r),dependencies:n,version:i.commitId.toString()},s(this,h).schemas[e]=r,r}async usePublishedSchema(e,t){if(e==null)throw new Error("Schema alias must be provided");return await this.loadSchema(t,e)}getDefinitionID(e){return s(this,h).definitions[e]??null}hasDefinitionAlias(e){return this.getDefinitionID(e)!=null}getDefinition(e){return s(this,m).definitions[e]??null}async createDefinition(e,t){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!A(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasDefinitionAlias(e))throw new Error(`Definition ${e} already exists`);await k(s(this,c));const[i,n]=await Promise.all([_(s(this,c),t,{schema:I.CIP11_DEFINITION_SCHEMA_URL}),this.loadSchema(t.schema)]),r=i.id.toString();return s(this,m).definitions[r]={alias:e,commits:await this.loadCommits(r),schema:n,version:i.commitId.toString()},s(this,h).definitions[e]=r,r}async usePublishedDefinition(e,t){if(this.hasDefinitionAlias(e))throw new Error(`Definition ${e} already exists`);const i=Y(t),[n,r]=await Promise.all([this.loadStream(t),this.loadCommits(i)]);return s(this,m).definitions[i]={alias:e,commits:r,schema:await this.loadSchema(n.content.schema),version:n.commitId.toString()},s(this,h).definitions[e]=i,i}getTileID(e){return s(this,h).tiles[e]??null}hasTileAlias(e){return this.getTileID(e)!=null}getTile(e){return s(this,m).tiles[e]??null}async createTile(e,t,i={}){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!A(s(this,c).did.id))throw new Error("Unsupported DID to create stream for model");if(this.hasTileAlias(e))throw new Error(`Tile ${e} already exists`);if(i.schema==null)throw new Error(`Missing schema to create tile ${e}`);const[n,r]=await Promise.all([_(s(this,c),t,i),this.loadSchema(i.schema)]),a=n.id.toString();return s(this,m).tiles[a]={alias:e,commits:await this.loadCommits(a),schema:r,version:n.commitId.toString()},s(this,h).tiles[e]=a,a}async usePublishedTile(e,t){if(this.hasTileAlias(e))throw new Error(`Tile ${e} already exists`);const i=Y(t),[n,r]=await Promise.all([this.loadStream(t),this.loadCommits(i)]);if(n.metadata.schema==null)throw new Error("Loaded tile has no schema defined");return s(this,m).tiles[i]={alias:e,commits:r,schema:await this.loadSchema(n.metadata.schema),version:n.commitId.toString()},s(this,h).tiles[e]=i,i}async toPublished(){return await x(s(this,c),s(this,m))}toJSON(){return Q(s(this,m))}};let Se=ee;h=new WeakMap,c=new WeakMap,m=new WeakMap,f=new WeakMap,M=new WeakMap;function L(e,t=""){const i=G.pascalCase(e);return i.startsWith(t)?i:t+i}function J(e,t,i,n){const r=t.title??"";if(t.type==="array")throw new Error("Unsupported item field of type array");if(t.type==="string"){const a=v(t);if(a==null)return{...t,type:"string"};const d=L(r,i),o={schemas:a,owner:n};return e.references[d]=o,{type:"reference",...o}}return t.type==="object"?{type:"object",name:P(e,t,{name:r,parent:i,owner:n})}:t}function P(e,t,i={}){const n=i.name??t.title;if(n==null)throw new Error("Schema must have a title");const r=L(n,i.parent);if(t.type==="string"){const a=v(t);a!=null&&(e.references[r]={schemas:a,owner:i.owner})}else if(t.type==="array"&&t.items!=null)e.lists[r]=J(e,t.items,r,i.owner);else if(t.type==="object"&&t.properties!=null){const a=t.required??[],d=Object.entries(t.properties).reduce((o,[l,u])=>{const y=u.title??l,w=G.camelCase(l),g={name:y,parent:r,owner:i.owner??r},D=a.includes(l);if(u.type==="string"){const F=v(u);if(F==null)o[w]={...u,required:D,type:"string"};else{const ie=L(y,r),U={schemas:F,owner:i.owner??r};e.references[ie]=U,o[w]={required:D,type:"reference",...U}}}else if(u.type==="array"){if(u.items==null)throw new Error(`Missing items in field ${l}`);o[w]={required:D,type:"list",name:P(e,u,g)}}else u.type==="object"?o[w]={required:D,type:"object",name:P(e,u,g)}:o[w]={...u,required:D};return o},{});e.objects[r]={fields:d,parents:i.parent?[i.parent]:null}}return r}async function ye(e){const t={collections:{},index:{},lists:{},objects:{},referenced:{},references:{},roots:{}},i=e.schemas.map(async a=>{const d=e.getSchemaID(a),o=await e.loadStream(d),l=o.content;if(l==null)throw new Error(`Could not load schema ${a}`);const u=o.commitId.toUrl();if(l.$comment?.startsWith(I.CIP88_APPEND_COLLECTION_PREFIX)){const y=l.$comment.substr(I.CIP88_APPEND_COLLECTION_PREFIX.length);await e.loadSchema(y);const g=(await e.loadStream(y)).content?.properties?.contents?.items?.oneOf?.[0];if(g==null)throw new Error(`Could not extract item schema ${a}`);t.collections[a]={schema:u,item:J(t,g,a,a)},t.referenced[u]={type:"collection",name:a}}else t.referenced[u]={type:"object",name:P(t,l)}}),n=e.definitions.map(async a=>{const d=e.getDefinitionID(a),o=await e.loadStream(d),l=o.content;if(l==null)throw new Error(`Could not load definition ${a}`);t.index[a]={id:o.id.toString(),schema:l.schema}}),r=e.tiles.map(async a=>{const d=e.getTileID(a),o=await e.loadStream(d),{schema:l}=o.metadata;if(l==null)throw new Error(`Missing schema for tile ${a}`);t.roots[a]={id:o.id.toString(),schema:l}});return await Promise.all([...i,...n,...r]),t}const te=new X.default({strict:!1}).compile({$schema:"http://json-schema.org/draft-07/schema#",$id:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/json-schema-secure.json#",title:"Meta-schema for the security assessment of JSON Schemas",description:"If a JSON AnySchema fails validation against this meta-schema, it may be unsafe to validate untrusted data",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}}},dependencies:{patternProperties:{description:"prevent slow validation of large property names",required:["propertyNames"],properties:{propertyNames:{required:["maxLength"]}}},uniqueItems:{description:"prevent slow validation of large non-scalar arrays",if:{properties:{uniqueItems:{const:!0},items:{properties:{type:{anyOf:[{enum:["object","array"]},{type:"array",contains:{enum:["object","array"]}}]}}}}},then:{required:["maxItems"]}},pattern:{description:"prevent slow pattern matching of large strings",required:["maxLength"]},format:{description:"prevent slow format validation of large strings",required:["maxLength"]}},properties:{additionalItems:{$ref:"#"},additionalProperties:{$ref:"#"},dependencies:{additionalProperties:{anyOf:[{type:"array"},{$ref:"#"}]}},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}]},definitions:{additionalProperties:{$ref:"#"}},patternProperties:{additionalProperties:{$ref:"#"}},properties:{additionalProperties:{$ref:"#"}},if:{$ref:"#"},then:{$ref:"#"},else:{$ref:"#"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"},contains:{$ref:"#"},propertyNames:{$ref:"#"}}});function ge(e){const t=new X.default;return ce.default(t),t.compile(e),te(e)}exports.ModelManager=Se,exports.addModelSchema=P,exports.applyMap=p,exports.createGraphQLModel=ye,exports.createModelDoc=_,exports.decodeDagJWS=V,exports.decodeDagJWSResult=j,exports.decodeEntryCommits=R,exports.decodeModel=b,exports.decodeSignedMap=le,exports.encodeDagJWS=z,exports.encodeDagJWSResult=O,exports.encodeEntryCommits=N,exports.encodeModel=Q,exports.encodeSignedMap=me,exports.extractSchemaReferences=T,exports.getItemField=J,exports.getReference=v,exports.isSecureSchema=ge,exports.promiseMap=H,exports.publishCommits=S,exports.publishDataStoreSchemas=k,exports.publishEncodedModel=we,exports.publishModel=x,exports.publishSignedMap=he,exports.streamIDToString=de,exports.validateSchemaSecure=te;
//# sourceMappingURL=lib.cjs.map
