"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinningAggregation = exports.UnknownPinningService = void 0;
const base64 = __importStar(require("@stablelib/base64"));
const sha256 = __importStar(require("@stablelib/sha256"));
class UnknownPinningService extends Error {
    constructor(designator) {
        super(`Unknown pinning service ${designator}`);
    }
}
exports.UnknownPinningService = UnknownPinningService;
const textEncoder = new TextEncoder();
function uniq(input) {
    return [...new Set(input)];
}
class PinningAggregation {
    constructor(backends) {
        this.backends = backends;
        const allIds = this.backends.map((b) => b.id).join('\n');
        const bytes = textEncoder.encode(allIds);
        const digest = base64.encodeURLSafe(sha256.hash(bytes));
        this.id = `pinning-aggregation@${digest}`;
    }
    static build(ipfs, connectionStrings, pinners = []) {
        const backends = connectionStrings.map((s) => {
            const protocol = s.match(`://`) ? new URL(s).protocol.replace(':', '') : s;
            const match = protocol.match(/^(\w+)\+?/);
            const designator = match ? match[1] : '';
            const found = pinners.find((pinner) => pinner.designator === designator);
            if (found) {
                return new found(s, ipfs);
            }
            else {
                throw new UnknownPinningService(designator);
            }
        });
        return new PinningAggregation(backends);
    }
    open() {
        this.backends.forEach((service) => service.open());
    }
    async close() {
        await Promise.all(this.backends.map(async (service) => service.close()));
    }
    async pin(cid) {
        await Promise.all(this.backends.map(async (service) => service.pin(cid)));
    }
    async unpin(cid) {
        Promise.all(this.backends.map(async (service) => service.unpin(cid))).catch(() => {
        });
    }
    async ls() {
        const perBackend = await Promise.all(this.backends.map((b) => b.ls()));
        const allCids = uniq(perBackend.flatMap((p) => Object.keys(p)));
        const result = {};
        allCids.forEach((cid) => {
            result[cid] = perBackend.flatMap((p) => p[cid]).filter(Boolean);
        });
        return result;
    }
    async info() {
        const perBackend = await Promise.all(this.backends.map((b) => b.info()));
        return Object.assign({}, ...perBackend);
    }
}
exports.PinningAggregation = PinningAggregation;
//# sourceMappingURL=index.js.map