"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Caip10LinkHandler = void 0;
const blockchain_utils_validation_1 = require("@ceramicnetwork/blockchain-utils-validation");
const stream_caip10_link_1 = require("@ceramicnetwork/stream-caip10-link");
const common_1 = require("@ceramicnetwork/common");
class Caip10LinkHandler {
    get type() {
        return stream_caip10_link_1.Caip10Link.STREAM_TYPE_ID;
    }
    get name() {
        return stream_caip10_link_1.Caip10Link.STREAM_TYPE_NAME;
    }
    get stream_constructor() {
        return stream_caip10_link_1.Caip10Link;
    }
    async applyCommit(commitData, context, state) {
        if (state == null) {
            return this._applyGenesis(commitData);
        }
        if (common_1.StreamUtils.isAnchorCommitData(commitData)) {
            return this._applyAnchor(context, commitData, state);
        }
        return this._applySigned(commitData, state);
    }
    async _applyGenesis(commitData) {
        const commit = commitData.commit;
        if (commit.data) {
            throw new Error('Caip10Link genesis commit cannot have data');
        }
        const state = {
            type: stream_caip10_link_1.Caip10Link.STREAM_TYPE_ID,
            content: null,
            next: {
                content: null,
            },
            metadata: commit.header,
            signature: common_1.SignatureStatus.GENESIS,
            anchorStatus: common_1.AnchorStatus.NOT_REQUESTED,
            log: [{ cid: commitData.cid, type: common_1.CommitType.GENESIS }],
        };
        if (!(state.metadata.controllers && state.metadata.controllers.length === 1)) {
            throw new Error('Exactly one controller must be specified');
        }
        return state;
    }
    async _applySigned(commitData, state) {
        const commit = commitData.commit;
        let validProof = null;
        try {
            validProof = await blockchain_utils_validation_1.validateLink(commit.data);
        }
        catch (e) {
            throw new Error('Error while validating link proof for caip10-link signed commit: ' + e.toString());
        }
        if (!validProof) {
            throw new Error('Invalid proof for signed commit');
        }
        if (state.signature !== common_1.SignatureStatus.GENESIS &&
            ((state.anchorStatus === common_1.AnchorStatus.ANCHORED &&
                validProof.timestamp < state.anchorProof.blockTimestamp) ||
                (state.anchorStatus !== common_1.AnchorStatus.ANCHORED &&
                    validProof.timestamp < state.next.metadata.lastUpdate))) {
            throw new Error('Invalid commit, proof timestamp too old');
        }
        const account = validProof.account || validProof.address;
        let [address, chainId] = account.split('@');
        const addressCaip10 = [address, chainId].join('@');
        if (addressCaip10.toLowerCase() !== state.metadata.controllers[0].toLowerCase()) {
            throw new Error("Address doesn't match stream controller");
        }
        state.log.push({ cid: commitData.cid, type: common_1.CommitType.SIGNED });
        return {
            ...state,
            signature: common_1.SignatureStatus.SIGNED,
            anchorStatus: common_1.AnchorStatus.NOT_REQUESTED,
            next: {
                content: validProof.did,
                metadata: {
                    ...state.metadata,
                    lastUpdate: validProof.timestamp,
                },
            },
        };
    }
    async _applyAnchor(context, commitData, state) {
        var _a;
        state.log.push({ cid: commitData.cid, type: common_1.CommitType.ANCHOR });
        let content = state.content;
        if ((_a = state.next) === null || _a === void 0 ? void 0 : _a.content) {
            content = state.next.content;
        }
        delete state.next;
        delete state.anchorScheduledFor;
        return {
            ...state,
            content,
            anchorStatus: common_1.AnchorStatus.ANCHORED,
            anchorProof: commitData.proof,
        };
    }
}
exports.Caip10LinkHandler = Caip10LinkHandler;
//# sourceMappingURL=caip10-link-handler.js.map