"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withFleet = exports.fleet = exports.swarmConnect = exports.createIPFS = void 0;
const dag_jose_1 = __importDefault(require("dag-jose"));
const blockcodec_to_ipld_format_1 = require("blockcodec-to-ipld-format");
const ipfs_core_1 = __importDefault(require("ipfs-core"));
const tmp_promise_1 = __importDefault(require("tmp-promise"));
const get_port_1 = __importDefault(require("get-port"));
async function createIPFS(overrideConfig = {}) {
    const format = blockcodec_to_ipld_format_1.convert(dag_jose_1.default);
    const tmpFolder = await tmp_promise_1.default.dir({ unsafeCleanup: true });
    const port = await get_port_1.default();
    const defaultConfig = {
        ipld: { formats: [format] },
        repo: `${tmpFolder.path}/ipfs${port}/`,
        config: {
            Addresses: { Swarm: [`/ip4/127.0.0.1/tcp/${port}`] },
            Bootstrap: [],
        },
    };
    const config = { ...defaultConfig, ...overrideConfig };
    const instance = await ipfs_core_1.default.create(config);
    return new Proxy(instance, {
        get(target, p) {
            if (p === 'stop') {
                tmpFolder.cleanup();
            }
            return target[p];
        },
    });
}
exports.createIPFS = createIPFS;
async function swarmConnect(a, b) {
    const addressB = (await b.id()).addresses[0];
    await a.swarm.connect(addressB);
}
exports.swarmConnect = swarmConnect;
function fleet(n, overrideConfig = {}) {
    return Promise.all(Array.from({ length: n }).map(() => createIPFS(overrideConfig)));
}
exports.fleet = fleet;
async function withFleet(n, task) {
    const instances = await fleet(n);
    try {
        await task(instances);
    }
    finally {
        instances.map((instance) => instance.stop());
    }
}
exports.withFleet = withFleet;
//# sourceMappingURL=ipfs-util.js.map