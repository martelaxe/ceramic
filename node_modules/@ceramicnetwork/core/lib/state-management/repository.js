"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Repository_deps;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Repository = void 0;
const streamid_1 = __importDefault(require("@ceramicnetwork/streamid"));
const common_1 = require("@ceramicnetwork/common");
const execution_queue_1 = require("./execution-queue");
const running_state_1 = require("./running-state");
const state_manager_1 = require("./state-manager");
const rxjs_1 = require("rxjs");
const state_cache_1 = require("./state-cache");
const utils_1 = __importDefault(require("../utils"));
const DEFAULT_LOAD_OPTS = { sync: common_1.SyncOptions.PREFER_CACHE, syncTimeoutSeconds: 3 };
class Repository {
    constructor(cacheLimit, concurrencyLimit, logger) {
        this.logger = logger;
        _Repository_deps.set(this, void 0);
        this.loadingQ = new execution_queue_1.ExecutionQueue(concurrencyLimit, logger);
        this.executionQ = new execution_queue_1.ExecutionQueue(concurrencyLimit, logger);
        this.inmemory = new state_cache_1.StateCache(cacheLimit, (state$) => state$.complete());
        this.updates$ = this.updates$.bind(this);
    }
    get pinStore() {
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore;
    }
    setDeps(deps) {
        __classPrivateFieldSet(this, _Repository_deps, deps, "f");
        this.stateManager = new state_manager_1.StateManager(deps.dispatcher, deps.pinStore, this.executionQ, deps.anchorService, deps.conflictResolution, this.logger, (streamId) => this.get(streamId), (streamId, opts) => this.load(streamId, opts));
    }
    fromMemory(streamId) {
        return this.inmemory.get(streamId.toString());
    }
    async fromStateStore(streamId) {
        const streamState = await __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.stateStore.load(streamId);
        if (streamState) {
            const runningState = new running_state_1.RunningState(streamState, true);
            this.add(runningState);
            const toRecover = runningState.value.anchorStatus === common_1.AnchorStatus.PENDING ||
                runningState.value.anchorStatus === common_1.AnchorStatus.PROCESSING;
            if (toRecover && this.stateManager.anchorService) {
                this.stateManager.confirmAnchorResponse(runningState);
            }
            return runningState;
        }
        else {
            return undefined;
        }
    }
    async fromNetwork(streamId) {
        const handler = __classPrivateFieldGet(this, _Repository_deps, "f").handlers.get(streamId.typeName);
        const genesisCid = streamId.cid;
        const commitData = await utils_1.default.getCommitData(__classPrivateFieldGet(this, _Repository_deps, "f").dispatcher, genesisCid);
        if (commitData == null) {
            throw new Error(`No genesis commit found with CID ${genesisCid.toString()}`);
        }
        commitData.disableTimecheck = true;
        const state = await handler.applyCommit(commitData, __classPrivateFieldGet(this, _Repository_deps, "f").context);
        await __classPrivateFieldGet(this, _Repository_deps, "f").stateValidation.validate(state, state.content);
        const state$ = new running_state_1.RunningState(state, false);
        this.add(state$);
        this.logger.verbose(`Genesis commit for stream ${streamId.toString()} successfully loaded`);
        return state$;
    }
    async _loadGenesis(streamId) {
        let stream = this.fromMemory(streamId);
        if (stream) {
            return [stream, true];
        }
        stream = await this.fromStateStore(streamId);
        if (stream) {
            return [stream, this.stateManager.wasPinnedStreamSynced(streamId)];
        }
        stream = await this.fromNetwork(streamId);
        return [stream, false];
    }
    async load(streamId, opts) {
        opts = { ...DEFAULT_LOAD_OPTS, ...opts };
        const state$ = await this.loadingQ.forStream(streamId).run(async () => {
            const [stream, synced] = await this._loadGenesis(streamId);
            if (opts.sync == common_1.SyncOptions.PREFER_CACHE && synced) {
                return stream;
            }
            if (opts.sync == common_1.SyncOptions.NEVER_SYNC) {
                return this.stateManager.verifyLoneGenesis(stream);
            }
            await this.stateManager.sync(stream, opts.syncTimeoutSeconds * 1000);
            return this.stateManager.verifyLoneGenesis(stream);
        });
        await this.handlePinOpts(state$, opts);
        return state$;
    }
    async loadAtCommit(commitId, opts) {
        const base$ = await this.load(commitId.baseID, opts);
        return this.stateManager.atCommit(base$, commitId);
    }
    async loadAtTime(streamId, opts) {
        const base$ = await this.load(streamId.baseID, opts);
        return this.stateManager.atTime(base$, opts.atTime);
    }
    async applyCommit(streamId, commit, opts) {
        const state$ = await this.stateManager.applyCommit(streamId, commit, opts);
        await this.applyWriteOpts(state$, opts);
        return state$;
    }
    async applyWriteOpts(state$, opts) {
        this.stateManager.applyWriteOpts(state$, opts);
        await this.handlePinOpts(state$, opts);
    }
    async handlePinOpts(state$, opts) {
        if (opts.pin) {
            await this.pin(state$);
        }
        else if (opts.pin === false) {
            await this.unpin(state$);
        }
    }
    async applyCreateOpts(streamId, opts) {
        const state = await this.load(streamId, opts);
        await this.applyWriteOpts(state, opts);
        return state;
    }
    async get(streamId) {
        return this.loadingQ.forStream(streamId).run(async () => {
            const fromMemory = this.fromMemory(streamId);
            if (fromMemory)
                return fromMemory;
            return this.fromStateStore(streamId);
        });
    }
    async streamState(streamId) {
        const fromMemory = this.inmemory.get(streamId.toString());
        if (fromMemory) {
            return fromMemory.state;
        }
        else {
            return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.stateStore.load(streamId);
        }
    }
    add(state$) {
        this.inmemory.set(state$.id.toString(), state$);
    }
    pin(state$, force) {
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.add(state$, force);
    }
    async unpin(state$, opts) {
        if (opts === null || opts === void 0 ? void 0 : opts.publish) {
            this.stateManager.publishTip(state$);
        }
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.rm(state$);
    }
    async listPinned(streamId) {
        return __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.ls(streamId);
    }
    updates$(init) {
        return new rxjs_1.Observable((subscriber) => {
            const id = new streamid_1.default(init.type, init.log[0].cid);
            this.get(id).then((found) => {
                const state$ = found || new running_state_1.RunningState(init, false);
                this.inmemory.endure(id.toString(), state$);
                state$.subscribe(subscriber).add(() => {
                    if (state$.observers.length === 0) {
                        this.inmemory.free(id.toString());
                    }
                });
            });
        });
    }
    async close() {
        await this.loadingQ.close();
        await this.executionQ.close();
        Array.from(this.inmemory).forEach(([id, stream]) => {
            this.inmemory.delete(id);
            stream.complete();
        });
        await __classPrivateFieldGet(this, _Repository_deps, "f").pinStore.close();
    }
}
exports.Repository = Repository;
_Repository_deps = new WeakMap();
//# sourceMappingURL=repository.js.map