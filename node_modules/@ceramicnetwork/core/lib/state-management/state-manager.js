"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateManager = void 0;
const conflict_resolution_1 = require("../conflict-resolution");
const common_1 = require("@ceramicnetwork/common");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const snapshot_state_1 = require("./snapshot-state");
const APPLY_ANCHOR_COMMIT_ATTEMPTS = 3;
class StateManager {
    constructor(dispatcher, pinStore, executionQ, anchorService, conflictResolution, logger, fromMemoryOrStore, load) {
        this.dispatcher = dispatcher;
        this.pinStore = pinStore;
        this.executionQ = executionQ;
        this.anchorService = anchorService;
        this.conflictResolution = conflictResolution;
        this.logger = logger;
        this.fromMemoryOrStore = fromMemoryOrStore;
        this.load = load;
        this.syncedPinnedStreams = new Set();
    }
    wasPinnedStreamSynced(streamId) {
        return this.syncedPinnedStreams.has(streamId.toString());
    }
    async sync(state$, timeoutMillis) {
        const tip$ = this.dispatcher.messageBus.queryNetwork(state$.id);
        await tip$
            .pipe(operators_1.takeUntil(rxjs_1.timer(timeoutMillis)), operators_1.concatMap((tip) => this._handleTip(state$, tip)))
            .toPromise();
        if (state$.isPinned) {
            this.syncedPinnedStreams.add(state$.id.toString());
        }
    }
    async verifyLoneGenesis(state$) {
        if (state$.value.log.length > 1) {
            return state$;
        }
        await this.conflictResolution.verifyLoneGenesis(state$.value);
        return state$;
    }
    async atCommit(state$, commitId) {
        return this.executionQ.forStream(commitId).run(async () => {
            const snapshot = await this.conflictResolution.snapshotAtCommit(state$.value, commitId);
            if (common_1.StreamUtils.isStateSupersetOf(snapshot, state$.value)) {
                state$.next(snapshot);
            }
            return new snapshot_state_1.SnapshotState(snapshot);
        });
    }
    atTime(state$, timestamp) {
        const commitId = conflict_resolution_1.commitAtTime(state$, timestamp);
        return this.atCommit(state$, commitId);
    }
    applyWriteOpts(state$, opts) {
        const anchor = opts.anchor;
        const publish = opts.publish;
        if (anchor) {
            this.anchor(state$);
        }
        if (publish) {
            this.publishTip(state$);
        }
    }
    async _handleTip(state$, cid, opts = {}) {
        var _a;
        opts.throwOnInvalidCommit = (_a = opts.throwOnInvalidCommit) !== null && _a !== void 0 ? _a : false;
        this.logger.verbose(`Learned of new tip ${cid.toString()} for stream ${state$.id.toString()}`);
        const next = await this.conflictResolution.applyTip(state$.value, cid, opts);
        if (next) {
            state$.next(next);
            this.logger.verbose(`Stream ${state$.id.toString()} successfully updated to tip ${cid.toString()}`);
            await this._updateStateIfPinned(state$);
            return true;
        }
        else {
            return false;
        }
    }
    async _updateStateIfPinned(state$) {
        const isPinned = Boolean(await this.pinStore.stateStore.load(state$.id));
        if (isPinned) {
            await this.pinStore.add(state$);
        }
    }
    publishTip(state$) {
        this.dispatcher.publishTip(state$.id, state$.tip);
    }
    update(streamId, tip) {
        this.executionQ.forStream(streamId).add(async () => {
            const state$ = await this.fromMemoryOrStore(streamId);
            if (state$)
                await this._handleTip(state$, tip);
        });
    }
    async applyCommit(streamId, commit, opts) {
        return this.executionQ.forStream(streamId).run(async () => {
            const state$ = await this.load(streamId, opts);
            const cid = await this.dispatcher.storeCommit(commit, streamId);
            await this._handleTip(state$, cid, opts);
            return state$;
        });
    }
    async _handleAnchorCommit(state$, tip, anchorCommit) {
        for (let remainingRetries = APPLY_ANCHOR_COMMIT_ATTEMPTS - 1; remainingRetries >= 0; remainingRetries--) {
            try {
                await this.executionQ.forStream(state$.id).run(async () => {
                    const applied = await this._handleTip(state$, anchorCommit);
                    if (applied) {
                        this.publishTip(state$);
                        if (remainingRetries < APPLY_ANCHOR_COMMIT_ATTEMPTS - 1) {
                            this.logger.imp(`Successfully applied anchor commit ${anchorCommit.toString()} for stream ${state$.id.toString()}`);
                        }
                    }
                });
                return;
            }
            catch (error) {
                this.logger.warn(`Error while applying anchor commit ${anchorCommit.toString()} for stream ${state$.id.toString()}, ${remainingRetries} retries remain. ${error}`);
                if (remainingRetries == 0) {
                    this.logger.err(`Anchor failed for commit ${tip.toString()} of stream ${state$.id.toString()}: ${error}`);
                    if (tip.equals(state$.tip)) {
                        state$.next({ ...state$.value, anchorStatus: common_1.AnchorStatus.FAILED });
                    }
                }
            }
        }
    }
    anchor(state$) {
        if (!this.anchorService) {
            throw new Error(`Anchor requested for stream ${state$.id.toString()} but anchoring is disabled`);
        }
        if (state$.value.anchorStatus == common_1.AnchorStatus.ANCHORED) {
            return rxjs_1.Subscription.EMPTY;
        }
        const anchorStatus$ = this.anchorService.requestAnchor(state$.id, state$.tip);
        return this._processAnchorResponse(state$, anchorStatus$);
    }
    confirmAnchorResponse(state$) {
        const anchorStatus$ = this.anchorService.pollForAnchorResponse(state$.id, state$.tip);
        return this._processAnchorResponse(state$, anchorStatus$);
    }
    _processAnchorResponse(state$, anchorStatus$) {
        const stopSignal = new rxjs_1.Subject();
        const subscription = anchorStatus$
            .pipe(operators_1.takeUntil(stopSignal), operators_1.concatMap(async (asr) => {
            if (!asr.cid.equals(state$.tip) && asr.status != common_1.AnchorStatus.ANCHORED) {
                return;
            }
            switch (asr.status) {
                case common_1.AnchorStatus.PENDING: {
                    const next = {
                        ...state$.value,
                        anchorStatus: common_1.AnchorStatus.PENDING,
                    };
                    if (asr.anchorScheduledFor)
                        next.anchorScheduledFor = asr.anchorScheduledFor;
                    state$.next(next);
                    await this._updateStateIfPinned(state$);
                    return;
                }
                case common_1.AnchorStatus.PROCESSING: {
                    state$.next({ ...state$.value, anchorStatus: common_1.AnchorStatus.PROCESSING });
                    await this._updateStateIfPinned(state$);
                    return;
                }
                case common_1.AnchorStatus.ANCHORED: {
                    await this._handleAnchorCommit(state$, asr.cid, asr.anchorCommit);
                    stopSignal.next();
                    return;
                }
                case common_1.AnchorStatus.FAILED: {
                    this.logger.warn(`Anchor failed for commit ${asr.cid.toString()} of stream ${asr.streamId}: ${asr.message}`);
                    state$.next({ ...state$.value, anchorStatus: common_1.AnchorStatus.FAILED });
                    stopSignal.next();
                    return;
                }
                default:
                    throw new common_1.UnreachableCaseError(asr, 'Unknown anchoring state');
            }
        }), operators_1.catchError((error) => {
            this.logger.warn(`Error while anchoring stream ${state$.id.toString()}:${error}`);
            this.logger.warn(error);
            return rxjs_1.empty();
        }))
            .subscribe();
        state$.add(subscription);
        return subscription;
    }
}
exports.StateManager = StateManager;
//# sourceMappingURL=state-manager.js.map