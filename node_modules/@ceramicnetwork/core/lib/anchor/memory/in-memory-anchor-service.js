"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _InMemoryAnchorService_ceramic, _InMemoryAnchorService_dispatcher, _InMemoryAnchorService_logger, _InMemoryAnchorService_anchorDelay, _InMemoryAnchorService_anchorOnRequest, _InMemoryAnchorService_verifySignatures, _InMemoryAnchorService_feed, _InMemoryAnchorService_anchors, _InMemoryAnchorService_queue;
Object.defineProperty(exports, "__esModule", { value: true });
const cids_1 = __importDefault(require("cids"));
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const common_1 = require("@ceramicnetwork/common");
const utils_1 = __importDefault(require("../../utils"));
const ipld_dag_cbor_1 = __importDefault(require("ipld-dag-cbor"));
const DID_MATCHER = '^(did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.-]+(:[a-zA-Z0-9_.-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?)([?][^#]*)?(#.*)?';
const CHAIN_ID = 'inmemory:12345';
class Candidate {
    constructor(cid, streamId, log) {
        this.cid = cid;
        this.streamId = streamId;
        this.log = log;
    }
    get key() {
        return this.streamId.toString();
    }
}
const SAMPLE_ETH_TX_HASH = 'bagjqcgzaday6dzalvmy5ady2m5a5legq5zrbsnlxfc2bfxej532ds7htpova';
class InMemoryAnchorService {
    constructor(_config) {
        var _a, _b, _c;
        _InMemoryAnchorService_ceramic.set(this, void 0);
        _InMemoryAnchorService_dispatcher.set(this, void 0);
        _InMemoryAnchorService_logger.set(this, void 0);
        _InMemoryAnchorService_anchorDelay.set(this, void 0);
        _InMemoryAnchorService_anchorOnRequest.set(this, void 0);
        _InMemoryAnchorService_verifySignatures.set(this, void 0);
        _InMemoryAnchorService_feed.set(this, new rxjs_1.Subject());
        _InMemoryAnchorService_anchors.set(this, new Map());
        _InMemoryAnchorService_queue.set(this, []);
        __classPrivateFieldSet(this, _InMemoryAnchorService_anchorDelay, (_a = _config === null || _config === void 0 ? void 0 : _config.anchorDelay) !== null && _a !== void 0 ? _a : 0, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_anchorOnRequest, (_b = _config === null || _config === void 0 ? void 0 : _config.anchorOnRequest) !== null && _b !== void 0 ? _b : true, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_verifySignatures, (_c = _config === null || _config === void 0 ? void 0 : _config.verifySignatures) !== null && _c !== void 0 ? _c : true, "f");
        __classPrivateFieldGet(this, _InMemoryAnchorService_feed, "f").subscribe((asr) => __classPrivateFieldGet(this, _InMemoryAnchorService_anchors, "f").set(asr.cid.toString(), asr));
    }
    async init() {
        return;
    }
    async getSupportedChains() {
        return [CHAIN_ID];
    }
    async anchor() {
        const candidates = await this._findCandidates();
        for (const candidate of candidates) {
            await this._process(candidate);
        }
        __classPrivateFieldSet(this, _InMemoryAnchorService_queue, [], "f");
    }
    async failPendingAnchors() {
        const candidates = await this._findCandidates();
        for (const candidate of candidates) {
            this._failCandidate(candidate, 'anchor failed');
        }
        __classPrivateFieldSet(this, _InMemoryAnchorService_queue, [], "f");
    }
    async _findCandidates() {
        const groupedCandidates = await this._groupCandidatesByStreamId(__classPrivateFieldGet(this, _InMemoryAnchorService_queue, "f"));
        return this._selectValidCandidates(groupedCandidates);
    }
    async _groupCandidatesByStreamId(candidates) {
        const result = {};
        await Promise.all(candidates.map(async (req) => {
            try {
                const commitData = await utils_1.default.getCommitData(__classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f"), req.cid, null, req.streamId);
                if (__classPrivateFieldGet(this, _InMemoryAnchorService_verifySignatures, "f") && common_1.StreamUtils.isSignedCommitData(commitData)) {
                    await this.verifySignedCommit(commitData.envelope);
                }
                const log = await this._loadCommitHistory(req.cid);
                const candidate = new Candidate(req.cid, req.streamId, log);
                if (!result[candidate.key]) {
                    result[candidate.key] = [];
                }
                result[candidate.key].push(candidate);
            }
            catch (e) {
                __classPrivateFieldGet(this, _InMemoryAnchorService_logger, "f").err(e);
                this._failCandidate(req, e.message);
            }
        }));
        return result;
    }
    _selectValidCandidates(groupedCandidates) {
        const result = [];
        for (const compositeKey of Object.keys(groupedCandidates)) {
            const candidates = groupedCandidates[compositeKey];
            let selected = null;
            for (const c of candidates) {
                if (selected == null) {
                    selected = c;
                    continue;
                }
                if (c.log.length < selected.log.length) {
                    this._failCandidate(c);
                }
                else if (c.log.length > selected.log.length) {
                    this._failCandidate(selected);
                    selected = c;
                }
                else {
                    if (c.cid.bytes < selected.cid.bytes) {
                        this._failCandidate(selected);
                        selected = c;
                    }
                    else {
                        this._failCandidate(c);
                    }
                }
            }
            result.push(selected);
        }
        return result;
    }
    _failCandidate(candidate, message) {
        if (!message) {
            message = `Rejecting request to anchor CID ${candidate.cid.toString()} for stream ${candidate.streamId.toString()} because there is a better CID to anchor for the same stream`;
        }
        __classPrivateFieldGet(this, _InMemoryAnchorService_feed, "f").next({
            status: common_1.AnchorStatus.FAILED,
            streamId: candidate.streamId,
            cid: candidate.cid,
            message,
        });
    }
    async _loadCommitHistory(commitId) {
        const history = [];
        let currentCommitId = commitId;
        for (;;) {
            const commitData = await utils_1.default.getCommitData(__classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f"), currentCommitId);
            if (common_1.StreamUtils.isAnchorCommitData(commitData)) {
                return history;
            }
            const prevCommitId = commitData.commit.prev;
            if (prevCommitId == null) {
                return history;
            }
            history.push(prevCommitId);
            currentCommitId = prevCommitId;
        }
    }
    set ceramic(ceramic) {
        var _a, _b;
        __classPrivateFieldSet(this, _InMemoryAnchorService_ceramic, ceramic, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_dispatcher, __classPrivateFieldGet(this, _InMemoryAnchorService_ceramic, "f").dispatcher, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_logger, (_b = (_a = __classPrivateFieldGet(this, _InMemoryAnchorService_ceramic, "f")) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.loggerProvider.getDiagnosticsLogger(), "f");
    }
    get url() {
        return '<inmemory>';
    }
    requestAnchor(streamId, tip) {
        const candidate = new Candidate(tip, streamId);
        if (__classPrivateFieldGet(this, _InMemoryAnchorService_anchorOnRequest, "f")) {
            this._process(candidate).catch((error) => {
                __classPrivateFieldGet(this, _InMemoryAnchorService_feed, "f").next({
                    status: common_1.AnchorStatus.FAILED,
                    streamId: candidate.streamId,
                    cid: candidate.cid,
                    message: error.message,
                });
            });
        }
        else {
            __classPrivateFieldGet(this, _InMemoryAnchorService_queue, "f").push(candidate);
        }
        __classPrivateFieldGet(this, _InMemoryAnchorService_feed, "f").next({
            status: common_1.AnchorStatus.PENDING,
            streamId: streamId,
            cid: tip,
            message: 'Sending anchoring request',
            anchorScheduledFor: null,
        });
        return this.pollForAnchorResponse(streamId, tip);
    }
    pollForAnchorResponse(streamId, tip) {
        const anchorResponse = __classPrivateFieldGet(this, _InMemoryAnchorService_anchors, "f").get(tip.toString());
        const feed$ = __classPrivateFieldGet(this, _InMemoryAnchorService_feed, "f").pipe(operators_1.filter((asr) => asr.streamId.equals(streamId) && asr.cid.equals(tip)));
        if (anchorResponse) {
            return rxjs_1.concat(rxjs_1.of(anchorResponse), feed$);
        }
        else {
            return rxjs_1.of({
                status: common_1.AnchorStatus.FAILED,
                streamId,
                cid: tip,
                message: 'Request not found',
            });
        }
    }
    async _publishAnchorCommit(streamId, commit) {
        const expectedCID = await ipld_dag_cbor_1.default.util.cid(new Uint8Array(ipld_dag_cbor_1.default.util.serialize(commit)));
        const stream = await __classPrivateFieldGet(this, _InMemoryAnchorService_ceramic, "f").applyCommit(streamId, commit, {
            publish: true,
            anchor: false,
        });
        const commitFound = null != stream.state.log.find((logEntry) => logEntry.cid.equals(expectedCID));
        if (!commitFound) {
            throw new Error(`Anchor commit not found in stream log after being applied to Ceramic node. This most likely means the commit was rejected by Ceramic's conflict resolution. StreamID: ${streamId.toString()}, found tip: ${stream.tip.toString()}`);
        }
        return expectedCID;
    }
    async _process(leaf) {
        const timestamp = Math.floor(Date.now() / 1000);
        const proofData = {
            chainId: CHAIN_ID,
            blockNumber: timestamp,
            blockTimestamp: timestamp,
            txHash: new cids_1.default(SAMPLE_ETH_TX_HASH),
            root: leaf.cid,
        };
        const proof = await __classPrivateFieldGet(this, _InMemoryAnchorService_dispatcher, "f").storeCommit(proofData);
        const commit = { proof, path: '', prev: leaf.cid, id: leaf.streamId.cid };
        const cid = await this._publishAnchorCommit(leaf.streamId, commit);
        const handle = setTimeout(() => {
            __classPrivateFieldGet(this, _InMemoryAnchorService_feed, "f").next({
                status: common_1.AnchorStatus.ANCHORED,
                streamId: leaf.streamId,
                cid: leaf.cid,
                message: 'CID successfully anchored',
                anchorCommit: cid,
            });
            clearTimeout(handle);
        }, __classPrivateFieldGet(this, _InMemoryAnchorService_anchorDelay, "f"));
    }
    async verifySignedCommit(envelope) {
        try {
            const { kid } = await __classPrivateFieldGet(this, _InMemoryAnchorService_ceramic, "f").did.verifyJWS(envelope);
            return kid.match(RegExp(DID_MATCHER))[1];
        }
        catch (e) {
            throw new Error('Invalid signature for signed commit. ' + e);
        }
    }
    async validateChainInclusion(proof) {
    }
}
_InMemoryAnchorService_ceramic = new WeakMap(), _InMemoryAnchorService_dispatcher = new WeakMap(), _InMemoryAnchorService_logger = new WeakMap(), _InMemoryAnchorService_anchorDelay = new WeakMap(), _InMemoryAnchorService_anchorOnRequest = new WeakMap(), _InMemoryAnchorService_verifySignatures = new WeakMap(), _InMemoryAnchorService_feed = new WeakMap(), _InMemoryAnchorService_anchors = new WeakMap(), _InMemoryAnchorService_queue = new WeakMap();
exports.default = InMemoryAnchorService;
//# sourceMappingURL=in-memory-anchor-service.js.map