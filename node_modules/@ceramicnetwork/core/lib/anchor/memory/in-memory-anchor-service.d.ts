import CID from 'cids';
import { Observable } from 'rxjs';
import { AnchorProof, AnchorService, AnchorServiceResponse, AnchorValidator, AnchorCommit } from '@ceramicnetwork/common';
import Ceramic from '../../ceramic';
import StreamID from '@ceramicnetwork/streamid';
import type { DagJWS } from 'dids';
declare class Candidate {
    readonly cid: CID;
    readonly streamId?: StreamID;
    readonly log?: CID[];
    constructor(cid: CID, streamId?: StreamID, log?: CID[]);
    get key(): string;
}
interface InMemoryAnchorConfig {
    anchorDelay?: number;
    anchorOnRequest?: boolean;
    verifySignatures?: boolean;
}
declare class InMemoryAnchorService implements AnchorService, AnchorValidator {
    #private;
    constructor(_config: InMemoryAnchorConfig);
    init(): Promise<void>;
    getSupportedChains(): Promise<Array<string>>;
    anchor(): Promise<void>;
    failPendingAnchors(): Promise<void>;
    _findCandidates(): Promise<Candidate[]>;
    _groupCandidatesByStreamId(candidates: Candidate[]): Promise<Record<string, Candidate[]>>;
    _selectValidCandidates(groupedCandidates: Record<string, Candidate[]>): Candidate[];
    _failCandidate(candidate: Candidate, message?: string): void;
    _loadCommitHistory(commitId: CID): Promise<CID[]>;
    set ceramic(ceramic: Ceramic);
    get url(): string;
    requestAnchor(streamId: StreamID, tip: CID): Observable<AnchorServiceResponse>;
    pollForAnchorResponse(streamId: StreamID, tip: CID): Observable<AnchorServiceResponse>;
    _publishAnchorCommit(streamId: StreamID, commit: AnchorCommit): Promise<CID>;
    _process(leaf: Candidate): Promise<void>;
    verifySignedCommit(envelope: DagJWS): Promise<string>;
    validateChainInclusion(proof: AnchorProof): Promise<void>;
}
export default InMemoryAnchorService;
//# sourceMappingURL=in-memory-anchor-service.d.ts.map