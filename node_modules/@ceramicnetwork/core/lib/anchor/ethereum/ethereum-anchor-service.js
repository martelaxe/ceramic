"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cids_1 = __importDefault(require("cids"));
const common_1 = require("@ceramicnetwork/common");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const POLL_INTERVAL = 60000;
const MAX_POLL_TIME = 86400000;
class EthereumAnchorService {
    constructor(anchorServiceUrl, logger) {
        this.anchorServiceUrl = anchorServiceUrl;
        this.requestsApiEndpoint = this.anchorServiceUrl + '/api/v0/requests';
        this.chainIdApiEndpoint = this.anchorServiceUrl + '/api/v0/service-info/supported_chains';
        this._logger = logger;
    }
    set ceramic(ceramic) {
    }
    get url() {
        return this.anchorServiceUrl;
    }
    async init() {
        const response = await common_1.fetchJson(this.chainIdApiEndpoint);
        if (response.supportedChains.length > 1) {
            throw new Error("Anchor service returned multiple supported chains, which isn't supported by js-ceramic yet");
        }
        this._chainId = response.supportedChains[0];
    }
    requestAnchor(streamId, tip) {
        const cidStreamPair = { cid: tip, streamId };
        return rxjs_1.concat(this._announcePending(cidStreamPair), this._makeRequest(cidStreamPair), this.pollForAnchorResponse(streamId, tip)).pipe(operators_1.catchError((error) => rxjs_1.of({
            status: common_1.AnchorStatus.FAILED,
            streamId: streamId,
            cid: tip,
            message: error.message,
        })));
    }
    async getSupportedChains() {
        return [this._chainId];
    }
    _announcePending(cidStream) {
        return rxjs_1.of({
            status: common_1.AnchorStatus.PENDING,
            streamId: cidStream.streamId,
            cid: cidStream.cid,
            message: 'Sending anchoring request',
            anchorScheduledFor: null,
        });
    }
    _makeRequest(cidStreamPair) {
        return rxjs_1.from(common_1.fetchJson(this.requestsApiEndpoint, {
            method: 'POST',
            body: {
                streamId: cidStreamPair.streamId.toString(),
                docId: cidStreamPair.streamId.toString(),
                cid: cidStreamPair.cid.toString(),
            },
        })).pipe(operators_1.map((response) => {
            return this.parseResponse(cidStreamPair, response);
        }));
    }
    pollForAnchorResponse(streamId, tip) {
        const started = new Date().getTime();
        const maxTime = started + MAX_POLL_TIME;
        const requestUrl = [this.requestsApiEndpoint, tip.toString()].join('/');
        const cidStream = { cid: tip, streamId };
        return rxjs_1.interval(POLL_INTERVAL).pipe(operators_1.concatMap(async () => {
            const now = new Date().getTime();
            if (now > maxTime) {
                throw new Error('Exceeded max timeout');
            }
            else {
                const response = await common_1.fetchJson(requestUrl);
                return this.parseResponse(cidStream, response);
            }
        }));
    }
    parseResponse(cidStream, json) {
        if (json.error) {
            return {
                status: common_1.AnchorStatus.FAILED,
                streamId: cidStream.streamId,
                cid: cidStream.cid,
                message: json.error,
            };
        }
        switch (json.status) {
            case 'PENDING':
                return {
                    status: common_1.AnchorStatus.PENDING,
                    streamId: cidStream.streamId,
                    cid: cidStream.cid,
                    message: json.message,
                    anchorScheduledFor: json.scheduledAt,
                };
            case 'PROCESSING':
                return {
                    status: common_1.AnchorStatus.PROCESSING,
                    streamId: cidStream.streamId,
                    cid: cidStream.cid,
                    message: json.message,
                };
            case 'FAILED':
                return {
                    status: common_1.AnchorStatus.FAILED,
                    streamId: cidStream.streamId,
                    cid: cidStream.cid,
                    message: json.message,
                };
            case 'COMPLETED': {
                const { anchorCommit } = json;
                const anchorCommitCid = new cids_1.default(anchorCommit.cid.toString());
                return {
                    status: common_1.AnchorStatus.ANCHORED,
                    streamId: cidStream.streamId,
                    cid: cidStream.cid,
                    message: json.message,
                    anchorCommit: anchorCommitCid,
                };
            }
            default:
                throw new Error(`Unexpected status: ${json.status}`);
        }
    }
}
exports.default = EthereumAnchorService;
//# sourceMappingURL=ethereum-anchor-service.js.map