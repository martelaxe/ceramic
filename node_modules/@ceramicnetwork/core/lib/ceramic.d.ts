import { Dispatcher } from './dispatcher';
import StreamID, { CommitID, StreamRef } from '@ceramicnetwork/streamid';
import { IpfsTopology } from '@ceramicnetwork/ipfs-topology';
import { CreateOpts, Stream, StreamHandler, Context, LoadOpts, AnchorService, CeramicApi, CeramicCommit, IpfsApi, PinApi, MultiQuery, PinningBackendStatic, LoggerProvider, UpdateOpts, SyncOptions, AnchorValidator, AnchorStatus } from '@ceramicnetwork/common';
import { DID } from 'dids';
import { PinStoreFactory } from './store/pin-store-factory';
import { Repository } from './state-management/repository';
import { HandlersMap } from './handlers-map';
export interface CeramicConfig {
    ethereumRpcUrl?: string;
    anchorServiceUrl?: string;
    stateStoreDirectory?: string;
    validateStreams?: boolean;
    ipfsPinningEndpoints?: string[];
    pinningBackends?: PinningBackendStatic[];
    loggerProvider?: LoggerProvider;
    gateway?: boolean;
    networkName?: string;
    pubsubTopic?: string;
    streamCacheLimit?: number;
    concurrentRequestsLimit?: number;
    useCentralizedPeerDiscovery?: boolean;
    syncOverride?: SyncOptions;
    [index: string]: any;
}
export interface CeramicModules {
    anchorService: AnchorService | null;
    anchorValidator: AnchorValidator;
    dispatcher: Dispatcher;
    ipfs: IpfsApi;
    ipfsTopology: IpfsTopology;
    loggerProvider: LoggerProvider;
    pinStoreFactory: PinStoreFactory;
    repository: Repository;
}
export interface CeramicParameters {
    gateway: boolean;
    networkOptions: CeramicNetworkOptions;
    validateStreams: boolean;
    loadOptsOverride: LoadOpts;
}
interface CeramicNetworkOptions {
    name: string;
    pubsubTopic: string;
}
export declare class Ceramic implements CeramicApi {
    readonly context: Context;
    readonly dispatcher: Dispatcher;
    readonly loggerProvider: LoggerProvider;
    readonly pin: PinApi;
    readonly repository: Repository;
    readonly _streamHandlers: HandlersMap;
    private readonly _anchorValidator;
    private readonly _gateway;
    private readonly _ipfsTopology;
    private readonly _logger;
    private readonly _networkOptions;
    private _supportedChains;
    private readonly _validateStreams;
    private readonly stateValidation;
    private readonly _loadOptsOverride;
    constructor(modules: CeramicModules, params: CeramicParameters);
    get ipfs(): IpfsApi;
    get did(): DID | undefined;
    set did(did: DID);
    private _buildPinApi;
    private static _generateNetworkOptions;
    private _loadSupportedChains;
    static _processConfig(ipfs: IpfsApi, config: CeramicConfig): [CeramicModules, CeramicParameters];
    static create(ipfs: IpfsApi, config?: CeramicConfig): Promise<Ceramic>;
    _init(doPeerDiscovery: boolean): Promise<void>;
    setDID(did: DID): Promise<void>;
    addStreamHandler<T extends Stream>(streamHandler: StreamHandler<T>): void;
    applyCommit<T extends Stream>(streamId: string | StreamID, commit: CeramicCommit, opts?: CreateOpts | UpdateOpts): Promise<T>;
    requestAnchor(streamId: string | StreamID, opts?: LoadOpts): Promise<AnchorStatus>;
    createStreamFromGenesis<T extends Stream>(type: number, genesis: any, opts?: CreateOpts): Promise<T>;
    loadStream<T extends Stream>(streamId: StreamID | CommitID | string, opts?: LoadOpts): Promise<T>;
    _ensureGenesis(genesis: CeramicCommit, streamRef: StreamRef): Promise<void>;
    _loadLinkedStreams(query: MultiQuery, timeout: number): Promise<Record<string, Stream>>;
    multiQuery(queries: Array<MultiQuery>, timeout?: number): Promise<Record<string, Stream>>;
    loadStreamCommits(streamId: string | StreamID): Promise<Record<string, any>[]>;
    getSupportedChains(): Promise<Array<string>>;
    close(): Promise<void>;
}
export default Ceramic;
//# sourceMappingURL=ceramic.d.ts.map