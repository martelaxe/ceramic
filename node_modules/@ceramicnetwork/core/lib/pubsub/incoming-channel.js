"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterExternal = exports.IncomingChannel = void 0;
const rxjs_1 = require("rxjs");
const task_queue_1 = require("./task-queue");
const rxjs_2 = require("rxjs");
const operators_1 = require("rxjs/operators");
function buildResubscribeQueue(logger) {
    return new task_queue_1.TaskQueue((error, retry) => {
        if (error.message.includes('Already subscribed')) {
            logger.debug(error.message);
        }
        else if (error.message.includes('The user aborted a request')) {
            retry();
        }
        else {
            logger.err(error);
        }
    });
}
class IncomingChannel extends rxjs_1.Observable {
    constructor(ipfs, topic, resubscribeEvery, pubsubLogger, logger) {
        super((subscriber) => {
            const handler = (message) => subscriber.next(message);
            const complete = () => subscriber.complete();
            this.tasks.add(() => this.subscribeToIpfs(handler, complete));
            return () => {
                this.tasks.clear();
                this.tasks.add(async () => {
                    var _a;
                    await ((_a = this.ipfs.pubsub) === null || _a === void 0 ? void 0 : _a.unsubscribe(this.topic, handler));
                });
            };
        });
        this.ipfs = ipfs;
        this.topic = topic;
        this.resubscribeEvery = resubscribeEvery;
        this.pubsubLogger = pubsubLogger;
        this.logger = logger;
        this.tasks = buildResubscribeQueue(logger);
    }
    async subscribeToIpfs(handler, complete) {
        const isRunning = this.ipfs && this.ipfs.pubsub;
        if (isRunning) {
            const onError = (error) => {
                console.warn(`IPFS pubsub subscription error, resubscribing: ${error}`);
                this.tasks.add(() => this.subscribeToIpfs(handler, complete));
            };
            try {
                const ipfsId = await this.ipfs.id();
                const peerId = ipfsId.id;
                await this.ipfs.pubsub.subscribe(this.topic, handler, { onError });
                this.pubsubLogger.log({ peer: peerId, event: 'subscribed', topic: this.topic });
            }
            catch (error) {
                console.warn(`Can not reach ipfs node, resubscribing: ${error}`);
                await new Promise((resolve) => setTimeout(resolve, this.resubscribeEvery));
                this.tasks.add(() => this.subscribeToIpfs(handler, complete));
            }
        }
        else {
            complete();
        }
    }
}
exports.IncomingChannel = IncomingChannel;
function filterExternal(ownPeerId$) {
    return rxjs_2.pipe(operators_1.concatMap((data) => {
        return ownPeerId$.pipe(operators_1.map((peerId) => ({ isOuter: data.from !== peerId, entry: data })));
    }), operators_1.filter((data) => data.isOuter), operators_1.map((data) => data.entry));
}
exports.filterExternal = filterExternal;
//# sourceMappingURL=incoming-channel.js.map