"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageBus = exports.MAX_RESPONSE_INTERVAL = void 0;
const pubsub_message_1 = require("./pubsub-message");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
exports.MAX_RESPONSE_INTERVAL = 300;
function betweenTimeout(betweenMs) {
    const stop = new rxjs_1.Subject();
    let trigger = undefined;
    return rxjs_1.pipe(operators_1.tap(() => {
        if (trigger)
            clearTimeout(trigger);
        trigger = setTimeout(() => {
            stop.next(true);
        }, betweenMs);
    }), operators_1.takeUntil(stop));
}
class MessageBus extends rxjs_1.Observable {
    constructor(pubsub) {
        super((subscriber) => {
            this.feed$.subscribe(subscriber);
        });
        this.pubsub = pubsub;
        this.outstandingQueries = new Map();
        this.feed$ = new rxjs_1.Subject();
        this.pubsubSubscription = this.pubsub.subscribe(this.feed$);
    }
    get closed() {
        return this.feed$.isStopped;
    }
    next(message) {
        if (this.closed) {
            return rxjs_1.Subscription.EMPTY;
        }
        else {
            return this.pubsub.next(message);
        }
    }
    queryNetwork(streamId) {
        const queryMessage = pubsub_message_1.buildQueryMessage(streamId);
        this.next(queryMessage);
        this.outstandingQueries.set(queryMessage.id, streamId);
        return this.pipe(operators_1.filter((message) => message.typ === pubsub_message_1.MsgType.RESPONSE && message.id === queryMessage.id), operators_1.map((message) => message.tips.get(streamId.toString())), operators_1.filter((tip) => !!tip), betweenTimeout(exports.MAX_RESPONSE_INTERVAL));
    }
    unsubscribe() {
        if (!this.pubsubSubscription.closed)
            this.pubsubSubscription.unsubscribe();
        this.feed$.complete();
    }
}
exports.MessageBus = MessageBus;
//# sourceMappingURL=message-bus.js.map