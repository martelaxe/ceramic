"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserialize = exports.serialize = exports.buildQueryMessage = exports.MsgType = void 0;
const streamid_1 = __importDefault(require("@ceramicnetwork/streamid"));
const cids_1 = __importDefault(require("cids"));
const common_1 = require("@ceramicnetwork/common");
const ipld_dag_cbor_1 = __importDefault(require("ipld-dag-cbor"));
const multihashes = __importStar(require("multihashes"));
const sha256 = __importStar(require("@stablelib/sha256"));
const util_1 = require("util");
const uint8arrays = __importStar(require("uint8arrays"));
var MsgType;
(function (MsgType) {
    MsgType[MsgType["UPDATE"] = 0] = "UPDATE";
    MsgType[MsgType["QUERY"] = 1] = "QUERY";
    MsgType[MsgType["RESPONSE"] = 2] = "RESPONSE";
    MsgType[MsgType["KEEPALIVE"] = 3] = "KEEPALIVE";
})(MsgType = exports.MsgType || (exports.MsgType = {}));
const textEncoder = new util_1.TextEncoder();
const textDecoder = new util_1.TextDecoder('utf-8');
function messageHash(message) {
    const encoded = ipld_dag_cbor_1.default.util.serialize(message);
    const id = sha256.hash(encoded);
    return uint8arrays.toString(multihashes.encode(id, 'sha2-256'), 'base64url');
}
function buildQueryMessage(streamId) {
    const payload = {
        typ: MsgType.QUERY,
        stream: streamId,
    };
    const id = messageHash({ ...payload, stream: streamId.toString() });
    return {
        ...payload,
        id: id,
    };
}
exports.buildQueryMessage = buildQueryMessage;
function serialize(message) {
    switch (message.typ) {
        case MsgType.QUERY: {
            return textEncoder.encode(JSON.stringify({
                ...message,
                doc: message.stream.toString(),
                stream: message.stream.toString(),
            }));
        }
        case MsgType.RESPONSE: {
            const tips = {};
            message.tips.forEach((value, key) => (tips[key] = value.toString()));
            const payload = {
                ...message,
                tips: tips,
            };
            return textEncoder.encode(JSON.stringify(payload));
        }
        case MsgType.UPDATE: {
            const payload = {
                typ: MsgType.UPDATE,
                doc: message.stream.toString(),
                stream: message.stream.toString(),
                tip: message.tip.toString(),
            };
            return textEncoder.encode(JSON.stringify(payload));
        }
        case MsgType.KEEPALIVE: {
            const payload = {
                typ: MsgType.KEEPALIVE,
                ts: message.ts,
            };
            return textEncoder.encode(JSON.stringify(payload));
        }
        default:
            throw new common_1.UnreachableCaseError(message, 'Unknown message type');
    }
}
exports.serialize = serialize;
function deserialize(message) {
    const asString = textDecoder.decode(message.data);
    const parsed = JSON.parse(asString);
    const typ = parsed.typ;
    switch (typ) {
        case MsgType.UPDATE: {
            const stream = streamid_1.default.fromString(parsed.stream || parsed.doc);
            return {
                typ: MsgType.UPDATE,
                stream,
                tip: new cids_1.default(parsed.tip),
            };
        }
        case MsgType.RESPONSE: {
            const tips = new Map();
            Object.entries(parsed.tips).forEach(([key, value]) => tips.set(key, new cids_1.default(value)));
            return {
                typ: MsgType.RESPONSE,
                id: parsed.id,
                tips: tips,
            };
        }
        case MsgType.QUERY: {
            const stream = streamid_1.default.fromString(parsed.stream || parsed.doc);
            return {
                typ: MsgType.QUERY,
                id: parsed.id,
                stream,
            };
        }
        case MsgType.KEEPALIVE: {
            return {
                typ: MsgType.KEEPALIVE,
                ts: parsed.ts,
            };
        }
        default:
            throw new common_1.UnreachableCaseError(typ, 'Unknown message type');
    }
}
exports.deserialize = deserialize;
//# sourceMappingURL=pubsub-message.js.map