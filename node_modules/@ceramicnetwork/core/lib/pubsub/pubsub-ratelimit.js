"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubsubRateLimit = void 0;
const rxjs_1 = require("rxjs");
const pubsub_message_1 = require("./pubsub-message");
const task_queue_1 = require("./task-queue");
const clock_source_1 = require("../clock-source");
class PubsubRateLimit extends rxjs_1.Observable {
    constructor(pubsub, logger, queriesPerSecond) {
        super((subscriber) => {
            pubsub.subscribe(subscriber);
        });
        this.pubsub = pubsub;
        this.logger = logger;
        this.queriesPerSecond = queriesPerSecond;
        this._recentQueries = [];
        this._clock = new clock_source_1.ClockSource();
        this._queryQueue = new task_queue_1.TaskQueue((err) => {
            this.logger.err(`Error while publishing pubsub QUERY message: ${err}`);
        });
        this.logger.debug(`Configuring pubsub to rate limit query messages to ${queriesPerSecond} per second`);
    }
    next(message) {
        const maxQueuedQueries = this.queriesPerSecond * 10;
        if (message.typ === pubsub_message_1.MsgType.QUERY) {
            if (this._queryQueue.size >= maxQueuedQueries) {
                this.logger.err(`Cannot publish query message to pubsub because we have exceeded the maximum allowed rate. Cannot have more than ${maxQueuedQueries} queued queries.`);
                return rxjs_1.empty().subscribe();
            }
            return rxjs_1.from(this._queryQueue.run(this._publishQuery.bind(this, message))).subscribe();
        }
        else {
            return this.pubsub.next(message);
        }
    }
    async _publishQuery(message) {
        if (this._recentQueries.length >= this.queriesPerSecond) {
            const now = this._clock.now();
            const oldestQuery = this._recentQueries.shift();
            const timeSinceOldestQuery = now.getTime() - oldestQuery.getTime();
            if (timeSinceOldestQuery < 1000) {
                this.logger.warn(`More than ${this.queriesPerSecond} query messages published in less than a second. Query messages will be rate limited`);
                await this._clock.waitUntil(new Date(oldestQuery.getTime() + 1000));
            }
        }
        this._recentQueries.push(this._clock.now());
        return this.pubsub.next(message);
    }
}
exports.PubsubRateLimit = PubsubRateLimit;
//# sourceMappingURL=pubsub-ratelimit.js.map