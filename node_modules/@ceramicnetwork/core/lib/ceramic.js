"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ceramic = void 0;
const dispatcher_1 = require("./dispatcher");
const streamid_1 = __importStar(require("@ceramicnetwork/streamid"));
const ipfs_topology_1 = require("@ceramicnetwork/ipfs-topology");
const common_1 = require("@ceramicnetwork/common");
const pin_store_factory_1 = require("./store/pin-store-factory");
const utils_1 = require("./utils");
const ethereum_anchor_service_1 = __importDefault(require("./anchor/ethereum/ethereum-anchor-service"));
const in_memory_anchor_service_1 = __importDefault(require("./anchor/memory/in-memory-anchor-service"));
const random_1 = require("@stablelib/random");
const local_pin_api_1 = require("./local-pin-api");
const repository_1 = require("./state-management/repository");
const handlers_map_1 = require("./handlers-map");
const state_validation_1 = require("./state-management/state-validation");
const stream_from_state_1 = require("./state-management/stream-from-state");
const conflict_resolution_1 = require("./conflict-resolution");
const ethereum_anchor_validator_1 = __importDefault(require("./anchor/ethereum/ethereum-anchor-validator"));
const DEFAULT_CACHE_LIMIT = 500;
const DEFAULT_QPS_LIMIT = 10;
const TESTING = process.env.NODE_ENV == 'test';
const TRAILING_SLASH = /\/$/;
const DEFAULT_ANCHOR_SERVICE_URLS = {
    [common_1.Networks.MAINNET]: 'https://cas.3boxlabs.com',
    [common_1.Networks.ELP]: 'https://cas.3boxlabs.com',
    [common_1.Networks.TESTNET_CLAY]: 'https://cas-clay.3boxlabs.com',
    [common_1.Networks.DEV_UNSTABLE]: 'https://cas-dev.3boxlabs.com',
    [common_1.Networks.LOCAL]: 'http://localhost:8081',
};
const DEFAULT_LOCAL_ETHEREUM_RPC = 'http://localhost:7545';
const SUPPORTED_CHAINS_BY_NETWORK = {
    [common_1.Networks.MAINNET]: ['eip155:1'],
    [common_1.Networks.ELP]: ['eip155:1'],
    [common_1.Networks.TESTNET_CLAY]: ['eip155:3', 'eip155:4'],
    [common_1.Networks.DEV_UNSTABLE]: ['eip155:3', 'eip155:4'],
    [common_1.Networks.LOCAL]: ['eip155:1337'],
    [common_1.Networks.INMEMORY]: ['inmemory:12345'],
};
const DEFAULT_APPLY_COMMIT_OPTS = { anchor: true, publish: true, sync: common_1.SyncOptions.PREFER_CACHE };
const DEFAULT_CREATE_FROM_GENESIS_OPTS = {
    anchor: true,
    publish: true,
    sync: common_1.SyncOptions.PREFER_CACHE,
};
const DEFAULT_LOAD_OPTS = { sync: common_1.SyncOptions.PREFER_CACHE };
const DEFAULT_NETWORK = common_1.Networks.INMEMORY;
const normalizeStreamID = (streamId) => {
    const streamRef = streamid_1.StreamRef.from(streamId);
    if (streamid_1.default.isInstance(streamRef)) {
        return streamRef;
    }
    else {
        throw new Error(`Not StreamID: ${streamRef}`);
    }
};
const tryStreamId = (id) => {
    try {
        return streamid_1.default.fromString(id);
    }
    catch (e) {
        return null;
    }
};
class Ceramic {
    constructor(modules, params) {
        this._ipfsTopology = modules.ipfsTopology;
        this.loggerProvider = modules.loggerProvider;
        this._logger = modules.loggerProvider.getDiagnosticsLogger();
        this.repository = modules.repository;
        this.dispatcher = modules.dispatcher;
        this.pin = this._buildPinApi();
        this._anchorValidator = modules.anchorValidator;
        this._gateway = params.gateway;
        this._networkOptions = params.networkOptions;
        this._validateStreams = params.validateStreams;
        this._loadOptsOverride = params.loadOptsOverride;
        this.context = {
            api: this,
            anchorService: modules.anchorService,
            ipfs: modules.ipfs,
            loggerProvider: modules.loggerProvider,
        };
        if (!this._gateway) {
            this.context.anchorService.ceramic = this;
        }
        this._streamHandlers = new handlers_map_1.HandlersMap(this._logger);
        this.stateValidation = this._validateStreams
            ? new state_validation_1.RealStateValidation(this.loadStream.bind(this))
            : new state_validation_1.FauxStateValidation();
        const conflictResolution = new conflict_resolution_1.ConflictResolution(modules.anchorValidator, this.stateValidation, this.dispatcher, this.context, this._streamHandlers);
        const pinStore = modules.pinStoreFactory.createPinStore();
        this.repository.setDeps({
            dispatcher: this.dispatcher,
            pinStore: pinStore,
            context: this.context,
            handlers: this._streamHandlers,
            anchorService: modules.anchorService,
            conflictResolution: conflictResolution,
            stateValidation: this.stateValidation,
        });
    }
    get ipfs() {
        return this.context.ipfs;
    }
    get did() {
        return this.context.did;
    }
    set did(did) {
        this.context.did = did;
    }
    _buildPinApi() {
        return new local_pin_api_1.LocalPinApi(this.repository, this._logger);
    }
    static _generateNetworkOptions(config) {
        const networkName = config.networkName || DEFAULT_NETWORK;
        if (config.pubsubTopic && networkName !== common_1.Networks.INMEMORY && networkName !== common_1.Networks.LOCAL) {
            throw new Error("Specifying pub/sub topic is only supported for the 'inmemory' and 'local' networks");
        }
        let pubsubTopic;
        switch (networkName) {
            case common_1.Networks.MAINNET: {
                pubsubTopic = '/ceramic/mainnet';
                break;
            }
            case common_1.Networks.ELP: {
                pubsubTopic = '/ceramic/mainnet';
                break;
            }
            case common_1.Networks.TESTNET_CLAY: {
                pubsubTopic = '/ceramic/testnet-clay';
                break;
            }
            case common_1.Networks.DEV_UNSTABLE: {
                pubsubTopic = '/ceramic/dev-unstable';
                break;
            }
            case common_1.Networks.LOCAL: {
                if (config.pubsubTopic) {
                    pubsubTopic = config.pubsubTopic;
                }
                else {
                    const rand = random_1.randomUint32();
                    pubsubTopic = '/ceramic/local-' + rand;
                }
                break;
            }
            case common_1.Networks.INMEMORY: {
                if (config.pubsubTopic) {
                    pubsubTopic = config.pubsubTopic;
                }
                else {
                    const rand = random_1.randomUint32();
                    pubsubTopic = '/ceramic/inmemory-' + rand;
                }
                break;
            }
            default: {
                throw new Error("Unrecognized Ceramic network name: '" +
                    networkName +
                    "'. Supported networks are: 'mainnet', 'testnet-clay', 'dev-unstable', 'local', 'inmemory'");
            }
        }
        if (networkName == common_1.Networks.MAINNET) {
            throw new Error('Ceramic mainnet is not yet supported');
        }
        return { name: networkName, pubsubTopic };
    }
    async _loadSupportedChains() {
        const networkName = this._networkOptions.name;
        const anchorService = this.context.anchorService;
        const networkChains = SUPPORTED_CHAINS_BY_NETWORK[networkName];
        const anchorServiceChains = await anchorService.getSupportedChains();
        const usableChains = networkChains.filter((c) => anchorServiceChains.includes(c));
        if (usableChains.length === 0) {
            throw new Error("No usable chainId for anchoring was found.  The ceramic network '" +
                networkName +
                "' supports the chains: ['" +
                networkChains.join("', '") +
                "'], but the configured anchor service '" +
                anchorService.url +
                "' only supports the chains: ['" +
                anchorServiceChains.join("', '") +
                "']");
        }
        this._supportedChains = usableChains;
    }
    static _processConfig(ipfs, config) {
        var _a, _b, _c, _d, _e;
        const loggerProvider = (_a = config.loggerProvider) !== null && _a !== void 0 ? _a : new common_1.LoggerProvider();
        const logger = loggerProvider.getDiagnosticsLogger();
        const pubsubLogger = loggerProvider.makeServiceLogger('pubsub');
        const networkOptions = Ceramic._generateNetworkOptions(config);
        let anchorService = null;
        if (!config.gateway) {
            const anchorServiceUrl = ((_b = config.anchorServiceUrl) === null || _b === void 0 ? void 0 : _b.replace(TRAILING_SLASH, '')) ||
                DEFAULT_ANCHOR_SERVICE_URLS[networkOptions.name];
            if ((networkOptions.name == common_1.Networks.MAINNET || networkOptions.name == common_1.Networks.ELP) &&
                anchorServiceUrl !== 'https://cas-internal.3boxlabs.com' &&
                anchorServiceUrl !== DEFAULT_ANCHOR_SERVICE_URLS[networkOptions.name]) {
                throw new Error('Cannot use custom anchor service on Ceramic mainnet');
            }
            anchorService =
                networkOptions.name != common_1.Networks.INMEMORY
                    ? new ethereum_anchor_service_1.default(anchorServiceUrl, logger)
                    : new in_memory_anchor_service_1.default(config);
        }
        let ethereumRpcUrl = config.ethereumRpcUrl;
        if (!ethereumRpcUrl && networkOptions.name == common_1.Networks.LOCAL) {
            ethereumRpcUrl = DEFAULT_LOCAL_ETHEREUM_RPC;
        }
        let anchorValidator;
        if (networkOptions.name == common_1.Networks.INMEMORY) {
            anchorValidator = anchorService;
        }
        else {
            anchorValidator = new ethereum_anchor_validator_1.default(ethereumRpcUrl, logger);
        }
        const pinStoreOptions = {
            networkName: networkOptions.name,
            stateStoreDirectory: config.stateStoreDirectory,
            pinningEndpoints: config.ipfsPinningEndpoints,
            pinningBackends: config.pinningBackends,
        };
        const loadOptsOverride = config.syncOverride ? { sync: config.syncOverride } : {};
        const streamCacheLimit = (_c = config.streamCacheLimit) !== null && _c !== void 0 ? _c : DEFAULT_CACHE_LIMIT;
        const concurrentRequestsLimit = (_d = config.concurrentRequestsLimit) !== null && _d !== void 0 ? _d : streamCacheLimit;
        const maxQueriesPerSecond = process.env.CERAMIC_PUBSUB_QPS_LIMIT
            ? parseInt(process.env.CERAMIC_PUBSUB_QPS_LIMIT)
            : DEFAULT_QPS_LIMIT;
        const ipfsTopology = new ipfs_topology_1.IpfsTopology(ipfs, networkOptions.name, logger);
        const pinStoreFactory = new pin_store_factory_1.PinStoreFactory(ipfs, pinStoreOptions);
        const repository = new repository_1.Repository(streamCacheLimit, concurrentRequestsLimit, logger);
        const dispatcher = new dispatcher_1.Dispatcher(ipfs, networkOptions.pubsubTopic, repository, logger, pubsubLogger, maxQueriesPerSecond);
        const params = {
            gateway: config.gateway,
            networkOptions,
            validateStreams: (_e = config.validateStreams) !== null && _e !== void 0 ? _e : true,
            loadOptsOverride,
        };
        const modules = {
            anchorService,
            anchorValidator,
            dispatcher,
            ipfs,
            ipfsTopology,
            loggerProvider,
            pinStoreFactory,
            repository,
        };
        return [modules, params];
    }
    static async create(ipfs, config = {}) {
        var _a;
        const [modules, params] = await Ceramic._processConfig(ipfs, config);
        const ceramic = new Ceramic(modules, params);
        const doPeerDiscovery = (_a = config.useCentralizedPeerDiscovery) !== null && _a !== void 0 ? _a : !TESTING;
        await ceramic._init(doPeerDiscovery);
        return ceramic;
    }
    async _init(doPeerDiscovery) {
        try {
            this._logger.imp(`Connecting to ceramic network '${this._networkOptions.name}' using pubsub topic '${this._networkOptions.pubsubTopic}'`);
            if (this._gateway) {
                this._logger.warn(`Starting in read-only gateway mode. All write operations will fail`);
            }
            if (doPeerDiscovery) {
                await this._ipfsTopology.start();
            }
            if (!this._gateway) {
                await this.context.anchorService.init();
                await this._loadSupportedChains();
                this._logger.imp(`Connected to anchor service '${this.context.anchorService.url}' with supported anchor chains ['${this._supportedChains.join("','")}']`);
            }
            await this._anchorValidator.init(this._supportedChains ? this._supportedChains[0] : null);
        }
        catch (err) {
            await this.close();
            throw err;
        }
    }
    async setDID(did) {
        this.context.did = did;
    }
    addStreamHandler(streamHandler) {
        this._streamHandlers.add(streamHandler);
    }
    async applyCommit(streamId, commit, opts = {}) {
        if (this._gateway) {
            throw new Error('Writes to streams are not supported in gateway mode');
        }
        opts = { ...DEFAULT_APPLY_COMMIT_OPTS, ...opts, ...this._loadOptsOverride };
        const state$ = await this.repository.applyCommit(normalizeStreamID(streamId), commit, opts);
        return stream_from_state_1.streamFromState(this.context, this._streamHandlers, state$.value, this.repository.updates$);
    }
    async requestAnchor(streamId, opts = {}) {
        opts = { ...DEFAULT_LOAD_OPTS, ...opts, ...this._loadOptsOverride };
        const effectiveStreamId = normalizeStreamID(streamId);
        const state = await this.repository.load(effectiveStreamId, opts);
        await this.repository.stateManager.anchor(state);
        return state.state.anchorStatus;
    }
    async createStreamFromGenesis(type, genesis, opts = {}) {
        opts = { ...DEFAULT_CREATE_FROM_GENESIS_OPTS, ...opts, ...this._loadOptsOverride };
        const genesisCid = await this.dispatcher.storeCommit(genesis);
        const streamId = new streamid_1.default(type, genesisCid);
        const state$ = await this.repository.applyCreateOpts(streamId, opts);
        return stream_from_state_1.streamFromState(this.context, this._streamHandlers, state$.value, this.repository.updates$);
    }
    async loadStream(streamId, opts = {}) {
        opts = { ...DEFAULT_LOAD_OPTS, ...opts, ...this._loadOptsOverride };
        const streamRef = streamid_1.StreamRef.from(streamId);
        if (streamid_1.CommitID.isInstance(streamRef)) {
            const snapshot$ = await this.repository.loadAtCommit(streamRef, opts);
            return stream_from_state_1.streamFromState(this.context, this._streamHandlers, snapshot$.value);
        }
        else if (opts.atTime) {
            const snapshot$ = await this.repository.loadAtTime(streamRef, opts);
            return stream_from_state_1.streamFromState(this.context, this._streamHandlers, snapshot$.value);
        }
        else {
            const base$ = await this.repository.load(streamRef.baseID, opts);
            return stream_from_state_1.streamFromState(this.context, this._streamHandlers, base$.value, this.repository.updates$);
        }
    }
    async _ensureGenesis(genesis, streamRef) {
        if (common_1.StreamUtils.isSignedCommitContainer(genesis) || common_1.StreamUtils.isSignedCommit(genesis)) {
            throw new Error('Given genesis commit is not deterministic');
        }
        const genesisCID = await this.ipfs.dag.put(genesis);
        if (!streamRef.cid.equals(genesisCID)) {
            throw new Error(`Given StreamID CID ${streamRef.cid.toString()} does not match given genesis content`);
        }
    }
    async _loadLinkedStreams(query, timeout) {
        var _a;
        const id = streamid_1.StreamRef.from(query.streamId);
        const pathTrie = new utils_1.PathTrie();
        (_a = query.paths) === null || _a === void 0 ? void 0 : _a.forEach((path) => pathTrie.add(path));
        if (query.genesis) {
            await this._ensureGenesis(query.genesis, id);
        }
        const index = {};
        const walkNext = async (node, streamId) => {
            let stream;
            try {
                stream = await utils_1.promiseTimeout(this.loadStream(streamId, { atTime: query.atTime }), timeout, `Timeout after ${timeout}ms`);
            }
            catch (e) {
                if (streamid_1.CommitID.isInstance(streamId)) {
                    this._logger.warn(`Error loading stream ${streamId.baseID.toString()} at commit ${streamId.commit.toString()} at time ${query.atTime} as part of a multiQuery request: ${e.toString()}`);
                }
                else {
                    this._logger.warn(`Error loading stream ${streamId.toString()} at time ${query.atTime} as part of a multiQuery request: ${e.toString()}`);
                }
                return Promise.resolve();
            }
            const streamRef = query.atTime ? streamId.atCommit(stream.tip) : streamId;
            index[streamRef.toString()] = stream;
            const promiseList = Object.keys(node.children).map((key) => {
                const keyStreamId = stream.content[key] ? tryStreamId(stream.content[key]) : null;
                if (keyStreamId)
                    return walkNext(node.children[key], keyStreamId);
                return Promise.resolve();
            });
            await Promise.all(promiseList);
        };
        await walkNext(pathTrie.root, id);
        return index;
    }
    async multiQuery(queries, timeout = 7000) {
        const queryResults = await Promise.all(queries.map((query) => {
            try {
                return this._loadLinkedStreams(query, timeout);
            }
            catch (e) {
                this._logger.warn(`Error during multiQuery: ${e.toString()}`);
                return Promise.resolve({});
            }
        }));
        const results = queryResults.reduce((acc, res) => ({ ...acc, ...res }), {});
        await Promise.all(Object.values(results).map((stream) => {
            if (!stream.isReadOnly) {
                return stream.sync({ sync: common_1.SyncOptions.NEVER_SYNC, syncTimeoutSeconds: 0 });
            }
        }));
        return results;
    }
    async loadStreamCommits(streamId) {
        const effectiveStreamId = normalizeStreamID(streamId);
        const stream = await this.loadStream(effectiveStreamId);
        const { state } = stream;
        const results = await Promise.all(state.log.map(async ({ cid }) => {
            const commit = await this.dispatcher.retrieveCommit(cid);
            return {
                cid: cid.toString(),
                value: await common_1.StreamUtils.convertCommitToSignedCommitContainer(commit, this.ipfs),
            };
        }));
        this._logger.verbose(`Successfully loaded ${results.length} commits for stream ${streamId.toString()}`);
        return results;
    }
    async getSupportedChains() {
        return this._supportedChains;
    }
    async close() {
        this._logger.imp('Closing Ceramic instance');
        await this.dispatcher.close();
        await this.repository.close();
        this._ipfsTopology.stop();
        this._logger.imp('Ceramic instance closed successfully');
    }
}
exports.Ceramic = Ceramic;
exports.default = Ceramic;
//# sourceMappingURL=ceramic.js.map