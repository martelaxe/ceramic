"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IpfsTopology = exports.DEFAULT_PEER_DISCOVERY_PERIOD = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const common_1 = require("@ceramicnetwork/common");
const multiaddr_1 = require("multiaddr");
const PEER_FILE_URLS = (ceramicNetwork) => {
    switch (ceramicNetwork) {
        case common_1.Networks.MAINNET:
        case common_1.Networks.ELP:
            return 'https://raw.githubusercontent.com/ceramicnetwork/peerlist/main/mainnet.json';
        case common_1.Networks.TESTNET_CLAY:
            return 'https://raw.githubusercontent.com/ceramicnetwork/peerlist/main/testnet-clay.json';
        case common_1.Networks.DEV_UNSTABLE:
            return 'https://raw.githubusercontent.com/ceramicnetwork/peerlist/main/dev-unstable.json';
        case common_1.Networks.LOCAL:
        case common_1.Networks.INMEMORY:
            return null;
        default: {
            const preventCompilingUnhandledCase = ceramicNetwork;
            return null;
        }
    }
};
const BASE_BOOTSTRAP_LIST = (ceramicNetwork) => {
    switch (ceramicNetwork) {
        case common_1.Networks.MAINNET:
        case common_1.Networks.ELP:
            return [
                new multiaddr_1.Multiaddr('/dns4/ipfs-ceramic-public-mainnet-external.ceramic.network/tcp/4012/wss/p2p/QmS2hvoNEfQTwqJC4v6xTvK8FpNR2s6AgDVsTL3unK11Ng'),
                new multiaddr_1.Multiaddr('/dns4/ipfs-ceramic-private-mainnet-external.3boxlabs.com/tcp/4012/wss/p2p/QmXALVsXZwPWTUbsT8G6VVzzgTJaAWRUD7FWL5f7d5ubAL'),
                new multiaddr_1.Multiaddr('/dns4/ipfs-ceramic-private-cas-mainnet-external.3boxlabs.com/tcp/4012/wss/p2p/QmUvEKXuorR7YksrVgA7yKGbfjWHuCRisw2cH9iqRVM9P8'),
            ];
        case common_1.Networks.TESTNET_CLAY:
            return [
                new multiaddr_1.Multiaddr('/dns4/ipfs-ceramic-public-clay-external.3boxlabs.com/tcp/4012/wss/p2p/QmWiY3CbNawZjWnHXx3p3DXsg21pZYTj4CRY1iwMkhP8r3'),
                new multiaddr_1.Multiaddr('/dns4/ipfs-ceramic-public-clay-external.ceramic.network/tcp/4012/wss/p2p/QmSqeKpCYW89XrHHxtEQEWXmznp6o336jzwvdodbrGeLTk'),
                new multiaddr_1.Multiaddr('/dns4/ipfs-ceramic-private-clay-external.3boxlabs.com/tcp/4012/wss/p2p/QmQotCKxiMWt935TyCBFTN23jaivxwrZ3uD58wNxeg5npi'),
                new multiaddr_1.Multiaddr('/dns4/ipfs-ceramic-private-cas-clay-external.3boxlabs.com/tcp/4012/wss/p2p/QmbeBTzSccH8xYottaYeyVX8QsKyox1ExfRx7T1iBqRyCd'),
            ];
        case common_1.Networks.DEV_UNSTABLE:
        case common_1.Networks.LOCAL:
        case common_1.Networks.INMEMORY:
            return null;
        default: {
            const preventCompilingUnhandledCase = ceramicNetwork;
            return null;
        }
    }
};
async function fetchJson(url) {
    try {
        const res = await cross_fetch_1.default(url).then((response) => response.json());
        if (res.error) {
            throw new Error(res.error);
        }
        return res;
    }
    catch (error) {
        return [];
    }
}
exports.DEFAULT_PEER_DISCOVERY_PERIOD = 1000 * 60 * 60;
class IpfsTopology {
    constructor(ipfs, ceramicNetwork, logger, period = exports.DEFAULT_PEER_DISCOVERY_PERIOD) {
        this.ipfs = ipfs;
        this.ceramicNetwork = ceramicNetwork;
        this.logger = logger;
        this.period = period;
    }
    async connect(peerList) {
        const addressList = peerList.map((peer) => new multiaddr_1.Multiaddr(peer));
        await this._forceBootstrapConnection(this.ipfs, addressList);
    }
    async forceConnection() {
        const base = BASE_BOOTSTRAP_LIST(this.ceramicNetwork) || [];
        const dynamic = await this._dynamicBoostrapList(this.ceramicNetwork);
        const bootstrapList = base.concat(dynamic);
        await this._forceBootstrapConnection(this.ipfs, bootstrapList);
    }
    async start() {
        await this.forceConnection();
        this.intervalId = setInterval(async () => {
            await this.forceConnection();
        }, this.period);
    }
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    async _dynamicBoostrapList(network) {
        const url = PEER_FILE_URLS(network);
        if (!url) {
            this.logger.warn(`Peer discovery is not supported for ceramic network: ${network}. This node may fail to load documents from other nodes on the network.`);
            return [];
        }
        this.logger.imp(`Connecting to peers found in '${url}'`);
        const list = await fetchJson(url);
        return (list === null || list === void 0 ? void 0 : list.map((peer) => new multiaddr_1.Multiaddr(peer))) || [];
    }
    async _forceBootstrapConnection(ipfs, bootstrapList) {
        const myPeerId = (await ipfs.id()).id;
        const filteredBootstrapList = bootstrapList.filter((addr) => {
            var _a;
            return !((_a = addr.getPeerId()) === null || _a === void 0 ? void 0 : _a.endsWith(myPeerId));
        });
        if (filteredBootstrapList.length === bootstrapList.length) {
            this.logger.warn(`This node with peerId ${myPeerId.toString()} is not included in the peer list for Ceramic network ${this.ceramicNetwork}. It will not be discoverable by other nodes in the network, and so data created against this node will not be available to the rest of the network.`);
        }
        await Promise.all(filteredBootstrapList.map(async (node) => {
            try {
                await ipfs.swarm.connect(node);
            }
            catch (error) {
                this.logger.warn(`Can not connect to ${node}`);
                this.logger.warn(error);
            }
        }));
        const connectedPeers = await ipfs.swarm.peers();
        if (connectedPeers.length > 0) {
            const peerAddresses = connectedPeers.map((obj) => obj.addr);
            this.logger.imp(`Connected to peers: ${peerAddresses.join(', ')}`);
        }
    }
}
exports.IpfsTopology = IpfsTopology;
//# sourceMappingURL=ipfs-topology.js.map