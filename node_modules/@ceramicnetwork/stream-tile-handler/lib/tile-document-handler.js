"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileDocumentHandler = void 0;
const fast_json_patch_1 = __importDefault(require("fast-json-patch"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const stream_tile_1 = require("@ceramicnetwork/stream-tile");
const common_1 = require("@ceramicnetwork/common");
const streamid_1 = require("@ceramicnetwork/streamid");
function stringArraysEqual(arr1, arr2) {
    if (arr1.length != arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
class TileDocumentHandler {
    get type() {
        return stream_tile_1.TileDocument.STREAM_TYPE_ID;
    }
    get name() {
        return stream_tile_1.TileDocument.STREAM_TYPE_NAME;
    }
    get stream_constructor() {
        return stream_tile_1.TileDocument;
    }
    async applyCommit(commitData, context, state) {
        if (state == null) {
            return this._applyGenesis(commitData, context);
        }
        if (common_1.StreamUtils.isAnchorCommitData(commitData)) {
            return this._applyAnchor(context, commitData, state);
        }
        return this._applySigned(commitData, state, context);
    }
    async _applyGenesis(commitData, context) {
        const payload = commitData.commit;
        const isSigned = common_1.StreamUtils.isSignedCommitData(commitData);
        if (isSigned) {
            await this._verifySignature(commitData, context, payload.header.controllers[0]);
        }
        else if (payload.data) {
            throw Error('Genesis commit with contents should always be signed');
        }
        if (!(payload.header.controllers && payload.header.controllers.length === 1)) {
            throw new Error('Exactly one controller must be specified');
        }
        return {
            type: stream_tile_1.TileDocument.STREAM_TYPE_ID,
            content: payload.data || {},
            metadata: payload.header,
            signature: isSigned ? common_1.SignatureStatus.SIGNED : common_1.SignatureStatus.GENESIS,
            anchorStatus: common_1.AnchorStatus.NOT_REQUESTED,
            log: [{ cid: commitData.cid, type: common_1.CommitType.GENESIS }],
        };
    }
    async _applySigned(commitData, state, context) {
        var _a, _b, _c, _d, _e, _f, _g;
        const controller = ((_c = (_b = (_a = state.next) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.controllers) === null || _c === void 0 ? void 0 : _c[0]) || state.metadata.controllers[0];
        await this._verifySignature(commitData, context, controller);
        const payload = commitData.commit;
        if (!payload.id.equals(state.log[0].cid)) {
            throw new Error(`Invalid streamId ${payload.id}, expected ${state.log[0].cid}`);
        }
        if (payload.header.controllers && payload.header.controllers.length !== 1) {
            throw new Error('Exactly one controller must be specified');
        }
        if (state.metadata.forbidControllerChange &&
            payload.header.controllers &&
            !stringArraysEqual(payload.header.controllers, state.metadata.controllers)) {
            const streamId = new streamid_1.StreamID(stream_tile_1.TileDocument.STREAM_TYPE_ID, state.log[0].cid);
            throw new Error(`Cannot change controllers since 'forbidControllerChange' is set. Tried to change controllers for Stream ${streamId} from ${JSON.stringify(state.metadata.controllers)} to ${payload.header.controllers}`);
        }
        if (payload.header.forbidControllerChange !== undefined &&
            payload.header.forbidControllerChange !== state.metadata.forbidControllerChange) {
            throw new Error("Changing 'forbidControllerChange' metadata property is not allowed");
        }
        const nextState = lodash_clonedeep_1.default(state);
        nextState.signature = common_1.SignatureStatus.SIGNED;
        nextState.anchorStatus = common_1.AnchorStatus.NOT_REQUESTED;
        nextState.log.push({ cid: commitData.cid, type: common_1.CommitType.SIGNED });
        const content = (_e = (_d = state.next) === null || _d === void 0 ? void 0 : _d.content) !== null && _e !== void 0 ? _e : state.content;
        const metadata = (_g = (_f = state.next) === null || _f === void 0 ? void 0 : _f.metadata) !== null && _g !== void 0 ? _g : state.metadata;
        nextState.next = {
            content: fast_json_patch_1.default.applyPatch(content, payload.data).newDocument,
            metadata: { ...metadata, ...payload.header },
        };
        return nextState;
    }
    async _applyAnchor(context, commitData, state) {
        var _a, _b;
        const proof = commitData.proof;
        state.log.push({ cid: commitData.cid, type: common_1.CommitType.ANCHOR, timestamp: proof.blockTimestamp });
        let content = state.content;
        let metadata = state.metadata;
        if ((_a = state.next) === null || _a === void 0 ? void 0 : _a.content) {
            content = state.next.content;
            delete state.next.content;
        }
        if ((_b = state.next) === null || _b === void 0 ? void 0 : _b.metadata) {
            metadata = state.next.metadata;
            delete state.next.metadata;
        }
        delete state.next;
        delete state.anchorScheduledFor;
        return {
            ...state,
            content,
            metadata,
            anchorStatus: common_1.AnchorStatus.ANCHORED,
            anchorProof: proof,
        };
    }
    async _verifySignature(commitData, context, controller) {
        await context.did.verifyJWS(commitData.envelope, {
            atTime: commitData.timestamp,
            issuer: controller,
            disableTimecheck: commitData.disableTimecheck,
        });
    }
}
exports.TileDocumentHandler = TileDocumentHandler;
//# sourceMappingURL=tile-document-handler.js.map