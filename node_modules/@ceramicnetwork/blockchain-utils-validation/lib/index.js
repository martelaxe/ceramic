"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateLink = void 0;
const ethereum_1 = __importDefault(require("./blockchains/ethereum"));
const filecoin_1 = __importDefault(require("./blockchains/filecoin"));
const polkadot_1 = __importDefault(require("./blockchains/polkadot"));
const eosio_1 = __importDefault(require("./blockchains/eosio"));
const cosmos_1 = __importDefault(require("./blockchains/cosmos"));
const near_1 = __importDefault(require("./blockchains/near"));
const tezos_1 = __importDefault(require("./blockchains/tezos"));
const caip_1 = require("caip");
const handlers = {
    [ethereum_1.default.namespace]: ethereum_1.default,
    [filecoin_1.default.namespace]: filecoin_1.default,
    [polkadot_1.default.namespace]: polkadot_1.default,
    [eosio_1.default.namespace]: eosio_1.default,
    [cosmos_1.default.namespace]: cosmos_1.default,
    [near_1.default.namespace]: near_1.default,
    [tezos_1.default.namespace]: tezos_1.default,
};
const findDID = (did) => { var _a; return (_a = did.match(/(did:\S+:\S+)/)) === null || _a === void 0 ? void 0 : _a[0]; };
async function validateLink(proof) {
    let namespace = ethereum_1.default.namespace;
    if (proof.version >= 2) {
        namespace = new caip_1.AccountID(proof.account).chainId.namespace;
    }
    const handler = handlers[namespace];
    if (!handler)
        throw new Error(`proof with namespace '${namespace}' not supported`);
    const validProof = await handler.validateLink(proof);
    if (validProof) {
        validProof.did = findDID(validProof.message);
        return validProof;
    }
    else {
        return null;
    }
}
exports.validateLink = validateLink;
//# sourceMappingURL=index.js.map