export class NftDidVector {
    constructor(vectorBuilder) {
        this.nftDid = vectorBuilder.nftDid;
        this.nftOwners = vectorBuilder.nftOwners;
        this.verificationMethods = vectorBuilder.verificationMethods;
        this.versionId = vectorBuilder.versionId;
        this.versionTime = vectorBuilder.versionTime;
        this.caip10Controller = vectorBuilder.caip10Controller;
        this.errorMessage = vectorBuilder.errorMessage;
    }
    getDidWithVersionId() {
        return this.nftDid.concat(`?versionId=${this.versionId}`);
    }
    getDidWithVersionTime() {
        return this.nftDid.concat(`?versionTime=${this.versionTime}`);
    }
    getResult() {
        if (this.errorMessage) {
            return {
                didDocument: null,
                didDocumentMetadata: {},
                didResolutionMetadata: {
                    error: 'invalidDid',
                    message: this.errorMessage,
                },
            };
        }
        const resolutionResult = {
            didDocument: {
                id: this.nftDid,
            },
            didDocumentMetadata: {},
            didResolutionMetadata: { contentType: 'application/did+json' },
        };
        if (this.verificationMethods)
            resolutionResult.didDocument.verificationMethod = [...this.verificationMethods];
        if (this.caip10Controller)
            resolutionResult.didDocument.controller = this.caip10Controller;
        return resolutionResult;
    }
}
export class NftDidVectorBuilder {
    constructor(caip2ChainId, nftNamespace) {
        this.nftDid = ''; // falsey, will throw if not made or provided
        this.caip2ChainId = caip2ChainId;
        this.nftNamespace = nftNamespace;
    }
    setNftContract(nftContract) {
        this.nftContract = nftContract;
        return this;
    }
    setNftId(nftId) {
        this.nftId = nftId;
        return this;
    }
    setNftOwners(nftOwners) {
        this.nftOwners = nftOwners;
        return this;
    }
    setNftDid(nftDid) {
        this.nftDid = nftDid;
        return this;
    }
    setVerificationMethods(methods) {
        this.verificationMethods = methods;
        return this;
    }
    setCaip10Controller(caip10Controller) {
        this.caip10Controller = caip10Controller;
        return this;
    }
    setErrorMessage(errorMessage) {
        this.errorMessage = errorMessage;
        return this;
    }
    setVersionId(versionId) {
        this.versionId = versionId;
        return this;
    }
    // Should be ISOString
    setVersionTime(versionTime) {
        this.versionTime = versionTime;
        return this;
    }
    build() {
        if (!this.nftDid)
            this.nftDid = this.makeDid();
        if (!this.errorMessage && !this.verificationMethods)
            this.verificationMethods = this.makeVerificationMethods();
        return new NftDidVector(this);
    }
    makeDid() {
        if (!this.nftContract || !this.nftId) {
            throw new Error('Must provide contract address and id OR DID.');
        }
        return `did:nft:${this.caip2ChainId}_${this.nftNamespace}:${this.nftContract}_${this.nftId}`;
    }
    makeVerificationMethods() {
        if (!this.nftOwners) {
            throw new Error('Must provide NftOwners');
        }
        else if (!this.nftDid) {
            throw new Error('Must provide Nft DID or args');
        }
        return this.nftOwners.slice().map((owner) => {
            return {
                id: `${this.nftDid}#${owner.slice(2, 14)}`,
                type: 'BlockchainVerificationMethod2021',
                controller: this.nftDid,
                blockchainAccountId: `${this.caip2ChainId}:${owner}`,
            };
        });
    }
}
//# sourceMappingURL=nft-did-vector.js.map